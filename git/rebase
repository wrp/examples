
To auto rebase, you can do something like:

GIT_SEQUENCE_EDITOR='sh -c "cat << EOF > $1
p d694644
p 4efcb5a
p 1826839
p 73137a3
EOF
"' git rebase -i HEAD~4

which will make the new history: d694644 -> 4efcb5a' -> 1826839' -> 73137a3'


To change the history from 1-2-3-4 to 2-1-4-3, you can do

GIT_SEQUENCE_EDITOR='perl -e '"'"'
	$f=shift;
	open F,"<",$f;
	@a=<F>;
	open F,">",$f;
	print F @a[1,0,3,2],@a[4..$#a]
	'"'"'' git rebase -i HEAD~5
(perl -i does not work in GIT_SEQUENCE_EDITOR)


A few alternatives suggested by Claude:

  1. --autosquash (if moving a commit to follow another):
  git commit --fixup=$target_oid
  git rebase -i --autosquash HEAD~n
  Git automatically moves fixup commits after their targets.

  2. sed for simple moves:
  # Move line 5 to line 3 (delete line 5, insert after line 2)
  GIT_SEQUENCE_EDITOR='sed -i "" "5{h;d}; 2G"' git rebase -i HEAD~5


  3. Cherry-pick approach (no rebase):
  git reset --hard HEAD~3
  git cherry-pick $oid_of_commit_5
  git cherry-pick $oid_of_commit_3
  git cherry-pick $oid_of_commit_4

  4. Shell script/alias:
  # In .gitconfig
  [alias]
      swap = "!f() { GIT_SEQUENCE_EDITOR=\"perl -e '$f=shift; open F, \"<\", $f; @a=<F>; @a[$1,$2]=@a[$2,$1]; open F, \">\", $f; print F @a'\" git rebase -i HEAD~$3; }; f"
  Then: git swap 2 4 (swap positions 2 and 4)
