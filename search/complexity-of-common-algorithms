O -> f = O(g) means that there exists c and n such that f(m) <= c*g(m) for all m > n (big 0)
M -> f = M(g) means that there exists u and n such that u*g(m) <= f(m) for all m > n (big Omega)
T -> f = T(g) means that there exists a, b, and n such that a*g(m) <= f(m) <= b*g(m) for all m > n (big Theta)

                                   Time
		    Best           Avg         Worst       Space
Selection sort     M(n^2)         T(n^2)       O(n^2)      O(1)
Bubble sort        M(n)           T(n^2)       O(n^2)      O(1)
Insertion sort     M(n)           T(n^2)       O(n^2)      O(1)
Heap sort          M(n log n)   T(n log n)   O(n log n)    O(1)
Quick sort         M(n log n)   T(n log n)     O(n^2)      O(n)
Merge sort         M(n log n)   T(n log n)   O(n log n)    O(n)
Bucket sort        M(n + k)     T(n + k)       O(n^2)      O(n)
Radix sort         M(nk)          T(nk)        O(nk)     O(n + k)
Count sort         M(n + k)     T(n + k)     O(n + k)      O(k)
Shell sort         M(n log n)   T(n log n)     O(n^2)      O(1)
Tim sort           M(n)         T(n log n)   O(n log n)    O(n)
Tree sort          M(n log n)   T(n log n)     O(n^2)      O(n)
Cube sort          M(n)         T(n log n)   O(n log n)    O(n)
Smooth sort        M(n)         T(n log n)   O(n log n)    O(n)
