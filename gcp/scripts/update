#!/bin/sh

# Naive script to record changes in gcp.  Directory structure should be like:
# project-name/
# |-- address/
# |-- firewall-rule/
# |-- image/
# |-- instance/
# |-- keys
# |-- target-pool/
# |-- forwarding-rule/
# |-- network/
# |-- project-info
# |-- sql-instance/
# |-- big-query/
# `-- sshKeys


. $(dirname $0)/funcs.sh

set_group_and_type() {
	group=compute
	orig_type="$(basename $(dirname "$1"))"
	type="$orig_type"s
	case $orig_type in
	big-query)
		group=bq;;
	address)
		type=addresses
		region=$(awk '$1 == host{print $2}' host="$host" ${1%/*}/list) \
			|| die "Can't get region for ${orig_type} $host"
		;;
	forwarding-rule|target-pool)
		region=$(awk '$1 == host{print $2}' host="$host" ${1%/*}/list) \
			|| die "Can't get region for ${orig_type} $host"
		;;
	sql-instance)
		type=instances
		group=sql
		;;
	instance)
		if test "$host" != list; then
			zone=$(awk '$1 == host{print $2}' \
				host="$host" ${1%/*}/list | grep .) \
			|| die "Can't get zone for ${orig_type} $host"
		fi
		;;
	esac
}


all_hosts() {
	# Update the description of each host listed in $1/list
	: ${FORCE=Auto update of all hosts in $1}
	export FORCE
	test -s $1/list || { echo "No entries in $1/list" >&2; return 1; }

	$(dirname $0)/purge $1 || return 1
	count=$(( $(wc -l < $1/list) - 1 ))

	trap 'tput ve' RETURN

	tput vi #  make cursor invisible
	el=$(tput el)
	awk 'NR>1 {print $1}' $1/list | while read host; do
		printf "\r(%d/%d) update $host$el" "$((++i))" "$count"
		$0 $1/$host || return 1
	done
	echo
}

execute() {
	echo "$@" >&2
	eval "$@"
}

main() {
	trap 'rm -f $TMPFILE' return
	local TMPFILE=$(mktemp)

	if test "$1" = all-lists; then
		test -z "$2" && die "commit message required (arg 2)"
		find $(dirname $0) -name list \
		| while read f; do FORCE="$2" "$0" $f; done
		exit
	fi

	# Each argument should be a path.  eg $project/$type/[$instance]
	# If the target of the path is a dir, update 'list' inside that dir
	# and then all of the machines
	unset do_all
	for x; do
		x=$(realpath $x)
		test -d "$x" && { do_all=1; x="$x"/list; }

		case $(basename $x) in
		project-info)
			execute gcloud compute project-info describe \
				--project=$(basename $(dirname $x))
		;;
		iam-policy)
			execute gcloud projects get-iam-policy $(basename $(dirname $x))
		;;
		*)
		PROJECT=$(basename $(dirname $(dirname "$x")))
		host=$(basename $x)
		if test "$host" != list && ! test -f "$(dirname "$x")"/list; then
			$0 "$x"/list
		fi
		set_group_and_type $x

		case $group in
		bq)
			case $host in
			list) bq ls --max_results 100000 --project_id=$PROJECT ;;
			*)
				test "$host" = "${host#*.}" && bq ls --project_id=$PROJECT $host
				bq show --project_id=$PROJECT $host
			;;
			esac
		;;
		*)
			case $host in
			list)
				# Fix host name width to 60 to try to minimize churn when gcloud
				# changes all the widths for reformat
				execute gcloud $group $type list --project=${PROJECT?} \
				| while read host n; do printf "%-60s%s\n" "$host" "$n"; done
			;;
			*)
				execute gcloud $group $type describe \
					${zone:+--zone="$zone"} \
					${region:+--region="$region"} \
					--project=${PROJECT?} \
					--format=json \
					$host \
			;;
			esac
		;;
		esac
		esac > $TMPFILE
		test -s $TMPFILE && cat $TMPFILE > "$x"

		(
		cd $(dirname $0)
		git add $x
		interactive_commit "$(printf \
			"Update $orig_type/$host$(test "$PROJECT" != gcloud &&
				echo " in $PROJECT")\n\n%s" \
			"${FORCE}"
		)"
		)
		test -n "$do_all" && all_hosts $(dirname $x)
	done
	return 0
}
if ! ( cd $(dirname $0); git diff-index --exit-code HEAD --); then
	die repo is dirty
fi

while getopts ":v" opt; do
	case $opt in
	v) set -x ;;
	*) die "illegal option -$OPTARG (-h for usage)";;
	esac
done
shift $(($OPTIND-1))

main "$@"
