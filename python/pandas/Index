Help on class Index in module pandas.core.indexes.base:

class Index(pandas.core.base.IndexOpsMixin, pandas.core.base.PandasObject)
 |  Index(data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index'
 |
 |  Immutable sequence used for indexing and alignment.
 |
 |  The basic object storing axis labels for all pandas objects.
 |
 |  Parameters
 |  ----------
 |  data : array-like (1-dimensional)
 |  dtype : NumPy dtype (default: object)
 |      If dtype is None, we find the dtype that best fits the data.
 |      If an actual dtype is provided, we coerce to that dtype if it's safe.
 |      Otherwise, an error will be raised.
 |  copy : bool
 |      Make a copy of input ndarray.
 |  name : object
 |      Name to be stored in the index.
 |  tupleize_cols : bool (default: True)
 |      When True, attempt to create a MultiIndex if possible.
 |
 |  See Also
 |  --------
 |  RangeIndex : Index implementing a monotonic integer range.
 |  CategoricalIndex : Index of :class:`Categorical` s.
 |  MultiIndex : A multi-level, or hierarchical Index.
 |  IntervalIndex : An Index of :class:`Interval` s.
 |  DatetimeIndex : Index of datetime64 data.
 |  TimedeltaIndex : Index of timedelta64 data.
 |  PeriodIndex : Index of Period data.
 |  NumericIndex : Index of numpy int/uint/float data.
 |  Int64Index : Index of purely int64 labels (deprecated).
 |  UInt64Index : Index of purely uint64 labels (deprecated).
 |  Float64Index : Index of  purely float64 labels (deprecated).
 |
 |  Notes
 |  -----
 |  An Index instance can **only** contain hashable objects
 |
 |  Examples
 |  --------
 |  >>> pd.Index([1, 2, 3])
 |  Int64Index([1, 2, 3], dtype='int64')
 |
 |  >>> pd.Index(list('abc'))
 |  Index(['a', 'b', 'c'], dtype='object')
 |
 |  Method resolution order:
 |      Index
 |      pandas.core.base.IndexOpsMixin
 |      pandas.core.arraylike.OpsMixin
 |      pandas.core.base.PandasObject
 |      pandas.core.accessor.DirNamesMixin
 |      builtins.object
 |
 |  Methods defined here:
 |
 |  __abs__(self) -> 'Index'
 |
 |  __and__(self, other)
 |
 |  __array__(self, dtype=None) -> 'np.ndarray'
 |      The array interface, return my values.
 |
 |  __array_ufunc__(self, ufunc: 'np.ufunc', method: 'str_t', *inputs, **kwargs)
 |
 |  __array_wrap__(self, result, context=None)
 |      Gets called after a ufunc and other functions e.g. np.split.
 |
 |  __bool__ = __nonzero__(self) -> 'NoReturn'
 |
 |  __contains__(self, key: 'Any') -> 'bool'
 |      Return a boolean indicating whether the provided key is in the index.
 |
 |      Parameters
 |      ----------
 |      key : label
 |          The key to check if it is present in the index.
 |
 |      Returns
 |      -------
 |      bool
 |          Whether the key search is in the index.
 |
 |      Raises
 |      ------
 |      TypeError
 |          If the key is not hashable.
 |
 |      See Also
 |      --------
 |      Index.isin : Returns an ndarray of boolean dtype indicating whether the
 |          list-like key is in the index.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([1, 2, 3, 4])
 |      >>> idx
 |      Int64Index([1, 2, 3, 4], dtype='int64')
 |
 |      >>> 2 in idx
 |      True
 |      >>> 6 in idx
 |      False
 |
 |  __copy__(self: '_IndexT', **kwargs) -> '_IndexT'
 |
 |  __deepcopy__(self: '_IndexT', memo=None) -> '_IndexT'
 |      Parameters
 |      ----------
 |      memo, default None
 |          Standard signature. Unused
 |
 |  __getitem__(self, key)
 |      Override numpy.ndarray's __getitem__ method to work as desired.
 |
 |      This function adds lists and Series as valid boolean indexers
 |      (ndarrays only supports ndarray with dtype=bool).
 |
 |      If resulting ndim != 1, plain ndarray is returned instead of
 |      corresponding `Index` subclass.
 |
 |  __iadd__(self, other)
 |
 |  __invert__(self) -> 'Index'
 |
 |  __len__(self) -> 'int'
 |      Return the length of the Index.
 |
 |  __neg__(self) -> 'Index'
 |
 |  __nonzero__(self) -> 'NoReturn'
 |
 |  __or__(self, other)
 |      Return self|value.
 |
 |  __pos__(self) -> 'Index'
 |
 |  __reduce__(self)
 |      Helper for pickle.
 |
 |  __repr__(self) -> 'str_t'
 |      Return a string representation for this object.
 |
 |  __setitem__(self, key, value)
 |
 |  __xor__(self, other)
 |
 |  all(self, *args, **kwargs)
 |      Return whether all elements are Truthy.
 |
 |      Parameters
 |      ----------
 |      *args
 |          Required for compatibility with numpy.
 |      **kwargs
 |          Required for compatibility with numpy.
 |
 |      Returns
 |      -------
 |      all : bool or array-like (if axis is specified)
 |          A single element array-like may be converted to bool.
 |
 |      See Also
 |      --------
 |      Index.any : Return whether any element in an Index is True.
 |      Series.any : Return whether any element in a Series is True.
 |      Series.all : Return whether all elements in a Series are True.
 |
 |      Notes
 |      -----
 |      Not a Number (NaN), positive infinity and negative infinity
 |      evaluate to True because these are not equal to zero.
 |
 |      Examples
 |      --------
 |      True, because nonzero integers are considered True.
 |
 |      >>> pd.Index([1, 2, 3]).all()
 |      True
 |
 |      False, because ``0`` is considered False.
 |
 |      >>> pd.Index([0, 1, 2]).all()
 |      False
 |
 |  any(self, *args, **kwargs)
 |      Return whether any element is Truthy.
 |
 |      Parameters
 |      ----------
 |      *args
 |          Required for compatibility with numpy.
 |      **kwargs
 |          Required for compatibility with numpy.
 |
 |      Returns
 |      -------
 |      any : bool or array-like (if axis is specified)
 |          A single element array-like may be converted to bool.
 |
 |      See Also
 |      --------
 |      Index.all : Return whether all elements are True.
 |      Series.all : Return whether all elements are True.
 |
 |      Notes
 |      -----
 |      Not a Number (NaN), positive infinity and negative infinity
 |      evaluate to True because these are not equal to zero.
 |
 |      Examples
 |      --------
 |      >>> index = pd.Index([0, 1, 2])
 |      >>> index.any()
 |      True
 |
 |      >>> index = pd.Index([0, 0, 0])
 |      >>> index.any()
 |      False
 |
 |  append(self, other: 'Index | Sequence[Index]') -> 'Index'
 |      Append a collection of Index options together.
 |
 |      Parameters
 |      ----------
 |      other : Index or list/tuple of indices
 |
 |      Returns
 |      -------
 |      Index
 |
 |  argmax(self, axis=None, skipna=True, *args, **kwargs) -> 'int'
 |      Return int position of the largest value in the Series.
 |
 |      If the maximum is achieved in multiple locations,
 |      the first row position is returned.
 |
 |      Parameters
 |      ----------
 |      axis : {None}
 |          Unused. Parameter needed for compatibility with DataFrame.
 |      skipna : bool, default True
 |          Exclude NA/null values when showing the result.
 |      *args, **kwargs
 |          Additional arguments and keywords for compatibility with NumPy.
 |
 |      Returns
 |      -------
 |      int
 |          Row position of the maximum value.
 |
 |      See Also
 |      --------
 |      Series.argmax : Return position of the maximum value.
 |      Series.argmin : Return position of the minimum value.
 |      numpy.ndarray.argmax : Equivalent method for numpy arrays.
 |      Series.idxmax : Return index label of the maximum values.
 |      Series.idxmin : Return index label of the minimum values.
 |
 |      Examples
 |      --------
 |      Consider dataset containing cereal calories
 |
 |      >>> s = pd.Series({'Corn Flakes': 100.0, 'Almond Delight': 110.0,
 |      ...                'Cinnamon Toast Crunch': 120.0, 'Cocoa Puff': 110.0})
 |      >>> s
 |      Corn Flakes              100.0
 |      Almond Delight           110.0
 |      Cinnamon Toast Crunch    120.0
 |      Cocoa Puff               110.0
 |      dtype: float64
 |
 |      >>> s.argmax()
 |      2
 |      >>> s.argmin()
 |      0
 |
 |      The maximum cereal calories is the third element and
 |      the minimum cereal calories is the first element,
 |      since series is zero-indexed.
 |
 |  argmin(self, axis=None, skipna=True, *args, **kwargs) -> 'int'
 |      Return int position of the smallest value in the Series.
 |
 |      If the minimum is achieved in multiple locations,
 |      the first row position is returned.
 |
 |      Parameters
 |      ----------
 |      axis : {None}
 |          Unused. Parameter needed for compatibility with DataFrame.
 |      skipna : bool, default True
 |          Exclude NA/null values when showing the result.
 |      *args, **kwargs
 |          Additional arguments and keywords for compatibility with NumPy.
 |
 |      Returns
 |      -------
 |      int
 |          Row position of the minimum value.
 |
 |      See Also
 |      --------
 |      Series.argmin : Return position of the minimum value.
 |      Series.argmax : Return position of the maximum value.
 |      numpy.ndarray.argmin : Equivalent method for numpy arrays.
 |      Series.idxmax : Return index label of the maximum values.
 |      Series.idxmin : Return index label of the minimum values.
 |
 |      Examples
 |      --------
 |      Consider dataset containing cereal calories
 |
 |      >>> s = pd.Series({'Corn Flakes': 100.0, 'Almond Delight': 110.0,
 |      ...                'Cinnamon Toast Crunch': 120.0, 'Cocoa Puff': 110.0})
 |      >>> s
 |      Corn Flakes              100.0
 |      Almond Delight           110.0
 |      Cinnamon Toast Crunch    120.0
 |      Cocoa Puff               110.0
 |      dtype: float64
 |
 |      >>> s.argmax()
 |      2
 |      >>> s.argmin()
 |      0
 |
 |      The maximum cereal calories is the third element and
 |      the minimum cereal calories is the first element,
 |      since series is zero-indexed.
 |
 |  argsort(self, *args, **kwargs) -> 'npt.NDArray[np.intp]'
 |      Return the integer indices that would sort the index.
 |
 |      Parameters
 |      ----------
 |      *args
 |          Passed to `numpy.ndarray.argsort`.
 |      **kwargs
 |          Passed to `numpy.ndarray.argsort`.
 |
 |      Returns
 |      -------
 |      np.ndarray[np.intp]
 |          Integer indices that would sort the index if used as
 |          an indexer.
 |
 |      See Also
 |      --------
 |      numpy.argsort : Similar method for NumPy arrays.
 |      Index.sort_values : Return sorted copy of Index.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index(['b', 'a', 'd', 'c'])
 |      >>> idx
 |      Index(['b', 'a', 'd', 'c'], dtype='object')
 |
 |      >>> order = idx.argsort()
 |      >>> order
 |      array([1, 0, 3, 2])
 |
 |      >>> idx[order]
 |      Index(['a', 'b', 'c', 'd'], dtype='object')
 |
 |  asof(self, label)
 |      Return the label from the index, or, if not present, the previous one.
 |
 |      Assuming that the index is sorted, return the passed index label if it
 |      is in the index, or return the previous index label if the passed one
 |      is not in the index.
 |
 |      Parameters
 |      ----------
 |      label : object
 |          The label up to which the method returns the latest index label.
 |
 |      Returns
 |      -------
 |      object
 |          The passed label if it is in the index. The previous label if the
 |          passed label is not in the sorted index or `NaN` if there is no
 |          such label.
 |
 |      See Also
 |      --------
 |      Series.asof : Return the latest value in a Series up to the
 |          passed index.
 |      merge_asof : Perform an asof merge (similar to left join but it
 |          matches on nearest key rather than equal key).
 |      Index.get_loc : An `asof` is a thin wrapper around `get_loc`
 |          with method='pad'.
 |
 |      Examples
 |      --------
 |      `Index.asof` returns the latest index label up to the passed label.
 |
 |      >>> idx = pd.Index(['2013-12-31', '2014-01-02', '2014-01-03'])
 |      >>> idx.asof('2014-01-01')
 |      '2013-12-31'
 |
 |      If the label is in the index, the method returns the passed label.
 |
 |      >>> idx.asof('2014-01-02')
 |      '2014-01-02'
 |
 |      If all of the labels in the index are later than the passed label,
 |      NaN is returned.
 |
 |      >>> idx.asof('1999-01-02')
 |      nan
 |
 |      If the index is not sorted, an error is raised.
 |
 |      >>> idx_not_sorted = pd.Index(['2013-12-31', '2015-01-02',
 |      ...                            '2014-01-03'])
 |      >>> idx_not_sorted.asof('2013-12-31')
 |      Traceback (most recent call last):
 |      ValueError: index must be monotonic increasing or decreasing
 |
 |  asof_locs(self, where: 'Index', mask: 'npt.NDArray[np.bool_]') -> 'npt.NDArray[np.intp]'
 |      Return the locations (indices) of labels in the index.
 |
 |      As in the `asof` function, if the label (a particular entry in
 |      `where`) is not in the index, the latest index label up to the
 |      passed label is chosen and its index returned.
 |
 |      If all of the labels in the index are later than a label in `where`,
 |      -1 is returned.
 |
 |      `mask` is used to ignore NA values in the index during calculation.
 |
 |      Parameters
 |      ----------
 |      where : Index
 |          An Index consisting of an array of timestamps.
 |      mask : np.ndarray[bool]
 |          Array of booleans denoting where values in the original
 |          data are not NA.
 |
 |      Returns
 |      -------
 |      np.ndarray[np.intp]
 |          An array of locations (indices) of the labels from the Index
 |          which correspond to the return values of the `asof` function
 |          for every element in `where`.
 |
 |  astype(self, dtype, copy: 'bool' = True)
 |      Create an Index with values cast to dtypes.
 |
 |      The class of a new Index is determined by dtype. When conversion is
 |      impossible, a TypeError exception is raised.
 |
 |      Parameters
 |      ----------
 |      dtype : numpy dtype or pandas type
 |          Note that any signed integer `dtype` is treated as ``'int64'``,
 |          and any unsigned integer `dtype` is treated as ``'uint64'``,
 |          regardless of the size.
 |      copy : bool, default True
 |          By default, astype always returns a newly allocated object.
 |          If copy is set to False and internal requirements on dtype are
 |          satisfied, the original data is used to create a new Index
 |          or the original Index is returned.
 |
 |      Returns
 |      -------
 |      Index
 |          Index with values cast to specified dtype.
 |
 |  copy(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT'
 |      Make a copy of this object.
 |
 |      Name and dtype sets those attributes on the new object.
 |
 |      Parameters
 |      ----------
 |      name : Label, optional
 |          Set name for new object.
 |      deep : bool, default False
 |      dtype : numpy dtype or pandas type, optional
 |          Set dtype for new object.
 |
 |          .. deprecated:: 1.2.0
 |              use ``astype`` method instead.
 |      names : list-like, optional
 |          Kept for compatibility with MultiIndex. Should not be used.
 |
 |          .. deprecated:: 1.4.0
 |              use ``name`` instead.
 |
 |      Returns
 |      -------
 |      Index
 |          Index refer to new object which is a copy of this object.
 |
 |      Notes
 |      -----
 |      In most cases, there should be no functional difference from using
 |      ``deep``, but if ``deep`` is passed it will attempt to deepcopy.
 |
 |  delete(self: '_IndexT', loc) -> '_IndexT'
 |      Make new Index with passed location(-s) deleted.
 |
 |      Parameters
 |      ----------
 |      loc : int or list of int
 |          Location of item(-s) which will be deleted.
 |          Use a list of locations to delete more than one value at the same time.
 |
 |      Returns
 |      -------
 |      Index
 |          Will be same type as self, except for RangeIndex.
 |
 |      See Also
 |      --------
 |      numpy.delete : Delete any rows and column from NumPy array (ndarray).
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index(['a', 'b', 'c'])
 |      >>> idx.delete(1)
 |      Index(['a', 'c'], dtype='object')
 |
 |      >>> idx = pd.Index(['a', 'b', 'c'])
 |      >>> idx.delete([0, 2])
 |      Index(['b'], dtype='object')
 |
 |  difference(self, other, sort=None)
 |      Return a new Index with elements of index not in `other`.
 |
 |      This is the set difference of two Index objects.
 |
 |      Parameters
 |      ----------
 |      other : Index or array-like
 |      sort : False or None, default None
 |          Whether to sort the resulting index. By default, the
 |          values are attempted to be sorted, but any TypeError from
 |          incomparable elements is caught by pandas.
 |
 |          * None : Attempt to sort the result, but catch any TypeErrors
 |            from comparing incomparable elements.
 |          * False : Do not sort the result.
 |
 |      Returns
 |      -------
 |      difference : Index
 |
 |      Examples
 |      --------
 |      >>> idx1 = pd.Index([2, 1, 3, 4])
 |      >>> idx2 = pd.Index([3, 4, 5, 6])
 |      >>> idx1.difference(idx2)
 |      Int64Index([1, 2], dtype='int64')
 |      >>> idx1.difference(idx2, sort=False)
 |      Int64Index([2, 1], dtype='int64')
 |
 |  drop(self, labels: 'Index | np.ndarray | Iterable[Hashable]', errors: 'IgnoreRaise' = 'raise') -> 'Index'
 |      Make new Index with passed list of labels deleted.
 |
 |      Parameters
 |      ----------
 |      labels : array-like or scalar
 |      errors : {'ignore', 'raise'}, default 'raise'
 |          If 'ignore', suppress error and existing labels are dropped.
 |
 |      Returns
 |      -------
 |      dropped : Index
 |          Will be same type as self, except for RangeIndex.
 |
 |      Raises
 |      ------
 |      KeyError
 |          If not all of the labels are found in the selected axis
 |
 |  drop_duplicates(self: '_IndexT', *, keep: 'str_t | bool' = 'first') -> '_IndexT'
 |      Return Index with duplicate values removed.
 |
 |      Parameters
 |      ----------
 |      keep : {'first', 'last', ``False``}, default 'first'
 |          - 'first' : Drop duplicates except for the first occurrence.
 |          - 'last' : Drop duplicates except for the last occurrence.
 |          - ``False`` : Drop all duplicates.
 |
 |      Returns
 |      -------
 |      deduplicated : Index
 |
 |      See Also
 |      --------
 |      Series.drop_duplicates : Equivalent method on Series.
 |      DataFrame.drop_duplicates : Equivalent method on DataFrame.
 |      Index.duplicated : Related method on Index, indicating duplicate
 |          Index values.
 |
 |      Examples
 |      --------
 |      Generate an pandas.Index with duplicate values.
 |
 |      >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'])
 |
 |      The `keep` parameter controls  which duplicate values are removed.
 |      The value 'first' keeps the first occurrence for each
 |      set of duplicated entries. The default value of keep is 'first'.
 |
 |      >>> idx.drop_duplicates(keep='first')
 |      Index(['lama', 'cow', 'beetle', 'hippo'], dtype='object')
 |
 |      The value 'last' keeps the last occurrence for each set of duplicated
 |      entries.
 |
 |      >>> idx.drop_duplicates(keep='last')
 |      Index(['cow', 'beetle', 'lama', 'hippo'], dtype='object')
 |
 |      The value ``False`` discards all sets of duplicated entries.
 |
 |      >>> idx.drop_duplicates(keep=False)
 |      Index(['cow', 'beetle', 'hippo'], dtype='object')
 |
 |  droplevel(self, level=0)
 |      Return index with requested level(s) removed.
 |
 |      If resulting index has only 1 level left, the result will be
 |      of Index type, not MultiIndex.
 |
 |      Parameters
 |      ----------
 |      level : int, str, or list-like, default 0
 |          If a string is given, must be the name of a level
 |          If list-like, elements must be names or indexes of levels.
 |
 |      Returns
 |      -------
 |      Index or MultiIndex
 |
 |      Examples
 |      --------
 |      >>> mi = pd.MultiIndex.from_arrays(
 |      ... [[1, 2], [3, 4], [5, 6]], names=['x', 'y', 'z'])
 |      >>> mi
 |      MultiIndex([(1, 3, 5),
 |                  (2, 4, 6)],
 |                 names=['x', 'y', 'z'])
 |
 |      >>> mi.droplevel()
 |      MultiIndex([(3, 5),
 |                  (4, 6)],
 |                 names=['y', 'z'])
 |
 |      >>> mi.droplevel(2)
 |      MultiIndex([(1, 3),
 |                  (2, 4)],
 |                 names=['x', 'y'])
 |
 |      >>> mi.droplevel('z')
 |      MultiIndex([(1, 3),
 |                  (2, 4)],
 |                 names=['x', 'y'])
 |
 |      >>> mi.droplevel(['x', 'y'])
 |      Int64Index([5, 6], dtype='int64', name='z')
 |
 |  dropna(self: '_IndexT', how: 'str_t' = 'any') -> '_IndexT'
 |      Return Index without NA/NaN values.
 |
 |      Parameters
 |      ----------
 |      how : {'any', 'all'}, default 'any'
 |          If the Index is a MultiIndex, drop the value when any or all levels
 |          are NaN.
 |
 |      Returns
 |      -------
 |      Index
 |
 |  duplicated(self, keep: "Literal['first', 'last', False]" = 'first') -> 'npt.NDArray[np.bool_]'
 |      Indicate duplicate index values.
 |
 |      Duplicated values are indicated as ``True`` values in the resulting
 |      array. Either all duplicates, all except the first, or all except the
 |      last occurrence of duplicates can be indicated.
 |
 |      Parameters
 |      ----------
 |      keep : {'first', 'last', False}, default 'first'
 |          The value or values in a set of duplicates to mark as missing.
 |
 |          - 'first' : Mark duplicates as ``True`` except for the first
 |            occurrence.
 |          - 'last' : Mark duplicates as ``True`` except for the last
 |            occurrence.
 |          - ``False`` : Mark all duplicates as ``True``.
 |
 |      Returns
 |      -------
 |      np.ndarray[bool]
 |
 |      See Also
 |      --------
 |      Series.duplicated : Equivalent method on pandas.Series.
 |      DataFrame.duplicated : Equivalent method on pandas.DataFrame.
 |      Index.drop_duplicates : Remove duplicate values from Index.
 |
 |      Examples
 |      --------
 |      By default, for each set of duplicated values, the first occurrence is
 |      set to False and all others to True:
 |
 |      >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama'])
 |      >>> idx.duplicated()
 |      array([False, False,  True, False,  True])
 |
 |      which is equivalent to
 |
 |      >>> idx.duplicated(keep='first')
 |      array([False, False,  True, False,  True])
 |
 |      By using 'last', the last occurrence of each set of duplicated values
 |      is set on False and all others on True:
 |
 |      >>> idx.duplicated(keep='last')
 |      array([ True, False,  True, False, False])
 |
 |      By setting keep on ``False``, all duplicates are True:
 |
 |      >>> idx.duplicated(keep=False)
 |      array([ True, False,  True, False,  True])
 |
 |  equals(self, other: 'Any') -> 'bool'
 |      Determine if two Index object are equal.
 |
 |      The things that are being compared are:
 |
 |      * The elements inside the Index object.
 |      * The order of the elements inside the Index object.
 |
 |      Parameters
 |      ----------
 |      other : Any
 |          The other object to compare against.
 |
 |      Returns
 |      -------
 |      bool
 |          True if "other" is an Index and it has the same elements and order
 |          as the calling index; False otherwise.
 |
 |      Examples
 |      --------
 |      >>> idx1 = pd.Index([1, 2, 3])
 |      >>> idx1
 |      Int64Index([1, 2, 3], dtype='int64')
 |      >>> idx1.equals(pd.Index([1, 2, 3]))
 |      True
 |
 |      The elements inside are compared
 |
 |      >>> idx2 = pd.Index(["1", "2", "3"])
 |      >>> idx2
 |      Index(['1', '2', '3'], dtype='object')
 |
 |      >>> idx1.equals(idx2)
 |      False
 |
 |      The order is compared
 |
 |      >>> ascending_idx = pd.Index([1, 2, 3])
 |      >>> ascending_idx
 |      Int64Index([1, 2, 3], dtype='int64')
 |      >>> descending_idx = pd.Index([3, 2, 1])
 |      >>> descending_idx
 |      Int64Index([3, 2, 1], dtype='int64')
 |      >>> ascending_idx.equals(descending_idx)
 |      False
 |
 |      The dtype is *not* compared
 |
 |      >>> int64_idx = pd.Index([1, 2, 3], dtype='int64')
 |      >>> int64_idx
 |      Int64Index([1, 2, 3], dtype='int64')
 |      >>> uint64_idx = pd.Index([1, 2, 3], dtype='uint64')
 |      >>> uint64_idx
 |      UInt64Index([1, 2, 3], dtype='uint64')
 |      >>> int64_idx.equals(uint64_idx)
 |      True
 |
 |  fillna(self, value=None, downcast=None)
 |      Fill NA/NaN values with the specified value.
 |
 |      Parameters
 |      ----------
 |      value : scalar
 |          Scalar value to use to fill holes (e.g. 0).
 |          This value cannot be a list-likes.
 |      downcast : dict, default is None
 |          A dict of item->dtype of what to downcast if possible,
 |          or the string 'infer' which will try to downcast to an appropriate
 |          equal type (e.g. float64 to int64 if possible).
 |
 |      Returns
 |      -------
 |      Index
 |
 |      See Also
 |      --------
 |      DataFrame.fillna : Fill NaN values of a DataFrame.
 |      Series.fillna : Fill NaN Values of a Series.
 |
 |  format(self, name: 'bool' = False, formatter: 'Callable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]'
 |      Render a string representation of the Index.
 |
 |  get_indexer(self, target, method: 'str_t | None' = None, limit: 'int | None' = None, tolerance=None) -> 'npt.NDArray[np.intp]'
 |      Compute indexer and mask for new index given the current index.
 |
 |      The indexer should be then used as an input to ndarray.take to align the
 |      current data to the new index.
 |
 |      Parameters
 |      ----------
 |      target : Index
 |      method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
 |          * default: exact matches only.
 |          * pad / ffill: find the PREVIOUS index value if no exact match.
 |          * backfill / bfill: use NEXT index value if no exact match
 |          * nearest: use the NEAREST index value if no exact match. Tied
 |            distances are broken by preferring the larger index value.
 |      limit : int, optional
 |          Maximum number of consecutive labels in ``target`` to match for
 |          inexact matches.
 |      tolerance : optional
 |          Maximum distance between original and new labels for inexact
 |          matches. The values of the index at the matching locations must
 |          satisfy the equation ``abs(index[indexer] - target) <= tolerance``.
 |
 |          Tolerance may be a scalar value, which applies the same tolerance
 |          to all values, or list-like, which applies variable tolerance per
 |          element. List-like includes list, tuple, array, Series, and must be
 |          the same size as the index and its dtype must exactly match the
 |          index's type.
 |
 |      Returns
 |      -------
 |      indexer : np.ndarray[np.intp]
 |          Integers from 0 to n - 1 indicating that the index at these
 |          positions matches the corresponding target values. Missing values
 |          in the target are marked by -1.
 |
 |      Notes
 |      -----
 |      Returns -1 for unmatched values, for further explanation see the
 |      example below.
 |
 |      Examples
 |      --------
 |      >>> index = pd.Index(['c', 'a', 'b'])
 |      >>> index.get_indexer(['a', 'b', 'x'])
 |      array([ 1,  2, -1])
 |
 |      Notice that the return value is an array of locations in ``index``
 |      and ``x`` is marked by -1, as it is not in ``index``.
 |
 |  get_indexer_for(self, target) -> 'npt.NDArray[np.intp]'
 |      Guaranteed return of an indexer even when non-unique.
 |
 |      This dispatches to get_indexer or get_indexer_non_unique
 |      as appropriate.
 |
 |      Returns
 |      -------
 |      np.ndarray[np.intp]
 |          List of indices.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([np.nan, 'var1', np.nan])
 |      >>> idx.get_indexer_for([np.nan])
 |      array([0, 2])
 |
 |  get_indexer_non_unique(self, target) -> 'tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]'
 |      Compute indexer and mask for new index given the current index.
 |
 |      The indexer should be then used as an input to ndarray.take to align the
 |      current data to the new index.
 |
 |      Parameters
 |      ----------
 |      target : Index
 |
 |      Returns
 |      -------
 |      indexer : np.ndarray[np.intp]
 |          Integers from 0 to n - 1 indicating that the index at these
 |          positions matches the corresponding target values. Missing values
 |          in the target are marked by -1.
 |      missing : np.ndarray[np.intp]
 |          An indexer into the target of the values not found.
 |          These correspond to the -1 in the indexer array.
 |
 |  get_level_values = _get_level_values(self, level) -> 'Index'
 |
 |  get_loc(self, key, method=None, tolerance=None)
 |      Get integer location, slice or boolean mask for requested label.
 |
 |      Parameters
 |      ----------
 |      key : label
 |      method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
 |          * default: exact matches only.
 |          * pad / ffill: find the PREVIOUS index value if no exact match.
 |          * backfill / bfill: use NEXT index value if no exact match
 |          * nearest: use the NEAREST index value if no exact match. Tied
 |            distances are broken by preferring the larger index value.
 |
 |          .. deprecated:: 1.4
 |              Use index.get_indexer([item], method=...) instead.
 |
 |      tolerance : int or float, optional
 |          Maximum distance from index value for inexact matches. The value of
 |          the index at the matching location must satisfy the equation
 |          ``abs(index[loc] - key) <= tolerance``.
 |
 |      Returns
 |      -------
 |      loc : int if unique index, slice if monotonic index, else mask
 |
 |      Examples
 |      --------
 |      >>> unique_index = pd.Index(list('abc'))
 |      >>> unique_index.get_loc('b')
 |      1
 |
 |      >>> monotonic_index = pd.Index(list('abbc'))
 |      >>> monotonic_index.get_loc('b')
 |      slice(1, 3, None)
 |
 |      >>> non_monotonic_index = pd.Index(list('abcb'))
 |      >>> non_monotonic_index.get_loc('b')
 |      array([False,  True, False,  True])
 |
 |  get_slice_bound(self, label, side: "Literal['left', 'right']", kind=<no_default>) -> 'int'
 |      Calculate slice bound that corresponds to given label.
 |
 |      Returns leftmost (one-past-the-rightmost if ``side=='right'``) position
 |      of given label.
 |
 |      Parameters
 |      ----------
 |      label : object
 |      side : {'left', 'right'}
 |      kind : {'loc', 'getitem'} or None
 |
 |          .. deprecated:: 1.4.0
 |
 |      Returns
 |      -------
 |      int
 |          Index of label.
 |
 |  get_value(self, series: 'Series', key)
 |      Fast lookup of value from 1-dimensional ndarray.
 |
 |      Only use this if you know what you're doing.
 |
 |      Returns
 |      -------
 |      scalar or Series
 |
 |  groupby(self, values) -> 'PrettyDict[Hashable, np.ndarray]'
 |      Group the index labels by a given array of values.
 |
 |      Parameters
 |      ----------
 |      values : array
 |          Values used to determine the groups.
 |
 |      Returns
 |      -------
 |      dict
 |          {group name -> group labels}
 |
 |  holds_integer(self) -> 'bool'
 |      Whether the type is an integer type.
 |
 |  identical(self, other) -> 'bool'
 |      Similar to equals, but checks that object attributes and types are also equal.
 |
 |      Returns
 |      -------
 |      bool
 |          If two Index objects have equal elements and same type True,
 |          otherwise False.
 |
 |  insert(self, loc: 'int', item) -> 'Index'
 |      Make new Index inserting new item at location.
 |
 |      Follows Python numpy.insert semantics for negative values.
 |
 |      Parameters
 |      ----------
 |      loc : int
 |      item : object
 |
 |      Returns
 |      -------
 |      new_index : Index
 |
 |  intersection(self, other, sort=False)
 |      Form the intersection of two Index objects.
 |
 |      This returns a new Index with elements common to the index and `other`.
 |
 |      Parameters
 |      ----------
 |      other : Index or array-like
 |      sort : False or None, default False
 |          Whether to sort the resulting index.
 |
 |          * False : do not sort the result.
 |          * None : sort the result, except when `self` and `other` are equal
 |            or when the values cannot be compared.
 |
 |      Returns
 |      -------
 |      intersection : Index
 |
 |      Examples
 |      --------
 |      >>> idx1 = pd.Index([1, 2, 3, 4])
 |      >>> idx2 = pd.Index([3, 4, 5, 6])
 |      >>> idx1.intersection(idx2)
 |      Int64Index([3, 4], dtype='int64')
 |
 |  is_(self, other) -> 'bool'
 |      More flexible, faster check like ``is`` but that works through views.
 |
 |      Note: this is *not* the same as ``Index.identical()``, which checks
 |      that metadata is also the same.
 |
 |      Parameters
 |      ----------
 |      other : object
 |          Other object to compare against.
 |
 |      Returns
 |      -------
 |      bool
 |          True if both have same underlying data, False otherwise.
 |
 |      See Also
 |      --------
 |      Index.identical : Works like ``Index.is_`` but also checks metadata.
 |
 |  is_boolean(self) -> 'bool'
 |      Check if the Index only consists of booleans.
 |
 |      Returns
 |      -------
 |      bool
 |          Whether or not the Index only consists of booleans.
 |
 |      See Also
 |      --------
 |      is_integer : Check if the Index only consists of integers.
 |      is_floating : Check if the Index is a floating type.
 |      is_numeric : Check if the Index only consists of numeric data.
 |      is_object : Check if the Index is of the object dtype.
 |      is_categorical : Check if the Index holds categorical data.
 |      is_interval : Check if the Index holds Interval objects.
 |      is_mixed : Check if the Index holds data with mixed data types.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([True, False, True])
 |      >>> idx.is_boolean()
 |      True
 |
 |      >>> idx = pd.Index(["True", "False", "True"])
 |      >>> idx.is_boolean()
 |      False
 |
 |      >>> idx = pd.Index([True, False, "True"])
 |      >>> idx.is_boolean()
 |      False
 |
 |  is_categorical(self) -> 'bool'
 |      Check if the Index holds categorical data.
 |
 |      Returns
 |      -------
 |      bool
 |          True if the Index is categorical.
 |
 |      See Also
 |      --------
 |      CategoricalIndex : Index for categorical data.
 |      is_boolean : Check if the Index only consists of booleans.
 |      is_integer : Check if the Index only consists of integers.
 |      is_floating : Check if the Index is a floating type.
 |      is_numeric : Check if the Index only consists of numeric data.
 |      is_object : Check if the Index is of the object dtype.
 |      is_interval : Check if the Index holds Interval objects.
 |      is_mixed : Check if the Index holds data with mixed data types.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index(["Watermelon", "Orange", "Apple",
 |      ...                 "Watermelon"]).astype("category")
 |      >>> idx.is_categorical()
 |      True
 |
 |      >>> idx = pd.Index([1, 3, 5, 7])
 |      >>> idx.is_categorical()
 |      False
 |
 |      >>> s = pd.Series(["Peter", "Victor", "Elisabeth", "Mar"])
 |      >>> s
 |      0        Peter
 |      1       Victor
 |      2    Elisabeth
 |      3          Mar
 |      dtype: object
 |      >>> s.index.is_categorical()
 |      False
 |
 |  is_floating(self) -> 'bool'
 |      Check if the Index is a floating type.
 |
 |      The Index may consist of only floats, NaNs, or a mix of floats,
 |      integers, or NaNs.
 |
 |      Returns
 |      -------
 |      bool
 |          Whether or not the Index only consists of only consists of floats, NaNs, or
 |          a mix of floats, integers, or NaNs.
 |
 |      See Also
 |      --------
 |      is_boolean : Check if the Index only consists of booleans.
 |      is_integer : Check if the Index only consists of integers.
 |      is_numeric : Check if the Index only consists of numeric data.
 |      is_object : Check if the Index is of the object dtype.
 |      is_categorical : Check if the Index holds categorical data.
 |      is_interval : Check if the Index holds Interval objects.
 |      is_mixed : Check if the Index holds data with mixed data types.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])
 |      >>> idx.is_floating()
 |      True
 |
 |      >>> idx = pd.Index([1.0, 2.0, np.nan, 4.0])
 |      >>> idx.is_floating()
 |      True
 |
 |      >>> idx = pd.Index([1, 2, 3, 4, np.nan])
 |      >>> idx.is_floating()
 |      True
 |
 |      >>> idx = pd.Index([1, 2, 3, 4])
 |      >>> idx.is_floating()
 |      False
 |
 |  is_integer(self) -> 'bool'
 |      Check if the Index only consists of integers.
 |
 |      Returns
 |      -------
 |      bool
 |          Whether or not the Index only consists of integers.
 |
 |      See Also
 |      --------
 |      is_boolean : Check if the Index only consists of booleans.
 |      is_floating : Check if the Index is a floating type.
 |      is_numeric : Check if the Index only consists of numeric data.
 |      is_object : Check if the Index is of the object dtype.
 |      is_categorical : Check if the Index holds categorical data.
 |      is_interval : Check if the Index holds Interval objects.
 |      is_mixed : Check if the Index holds data with mixed data types.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([1, 2, 3, 4])
 |      >>> idx.is_integer()
 |      True
 |
 |      >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])
 |      >>> idx.is_integer()
 |      False
 |
 |      >>> idx = pd.Index(["Apple", "Mango", "Watermelon"])
 |      >>> idx.is_integer()
 |      False
 |
 |  is_interval(self) -> 'bool'
 |      Check if the Index holds Interval objects.
 |
 |      Returns
 |      -------
 |      bool
 |          Whether or not the Index holds Interval objects.
 |
 |      See Also
 |      --------
 |      IntervalIndex : Index for Interval objects.
 |      is_boolean : Check if the Index only consists of booleans.
 |      is_integer : Check if the Index only consists of integers.
 |      is_floating : Check if the Index is a floating type.
 |      is_numeric : Check if the Index only consists of numeric data.
 |      is_object : Check if the Index is of the object dtype.
 |      is_categorical : Check if the Index holds categorical data.
 |      is_mixed : Check if the Index holds data with mixed data types.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([pd.Interval(left=0, right=5),
 |      ...                 pd.Interval(left=5, right=10)])
 |      >>> idx.is_interval()
 |      True
 |
 |      >>> idx = pd.Index([1, 3, 5, 7])
 |      >>> idx.is_interval()
 |      False
 |
 |  is_mixed(self) -> 'bool'
 |      Check if the Index holds data with mixed data types.
 |
 |      Returns
 |      -------
 |      bool
 |          Whether or not the Index holds data with mixed data types.
 |
 |      See Also
 |      --------
 |      is_boolean : Check if the Index only consists of booleans.
 |      is_integer : Check if the Index only consists of integers.
 |      is_floating : Check if the Index is a floating type.
 |      is_numeric : Check if the Index only consists of numeric data.
 |      is_object : Check if the Index is of the object dtype.
 |      is_categorical : Check if the Index holds categorical data.
 |      is_interval : Check if the Index holds Interval objects.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index(['a', np.nan, 'b'])
 |      >>> idx.is_mixed()
 |      True
 |
 |      >>> idx = pd.Index([1.0, 2.0, 3.0, 5.0])
 |      >>> idx.is_mixed()
 |      False
 |
 |  is_numeric(self) -> 'bool'
 |      Check if the Index only consists of numeric data.
 |
 |      Returns
 |      -------
 |      bool
 |          Whether or not the Index only consists of numeric data.
 |
 |      See Also
 |      --------
 |      is_boolean : Check if the Index only consists of booleans.
 |      is_integer : Check if the Index only consists of integers.
 |      is_floating : Check if the Index is a floating type.
 |      is_object : Check if the Index is of the object dtype.
 |      is_categorical : Check if the Index holds categorical data.
 |      is_interval : Check if the Index holds Interval objects.
 |      is_mixed : Check if the Index holds data with mixed data types.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])
 |      >>> idx.is_numeric()
 |      True
 |
 |      >>> idx = pd.Index([1, 2, 3, 4.0])
 |      >>> idx.is_numeric()
 |      True
 |
 |      >>> idx = pd.Index([1, 2, 3, 4])
 |      >>> idx.is_numeric()
 |      True
 |
 |      >>> idx = pd.Index([1, 2, 3, 4.0, np.nan])
 |      >>> idx.is_numeric()
 |      True
 |
 |      >>> idx = pd.Index([1, 2, 3, 4.0, np.nan, "Apple"])
 |      >>> idx.is_numeric()
 |      False
 |
 |  is_object(self) -> 'bool'
 |      Check if the Index is of the object dtype.
 |
 |      Returns
 |      -------
 |      bool
 |          Whether or not the Index is of the object dtype.
 |
 |      See Also
 |      --------
 |      is_boolean : Check if the Index only consists of booleans.
 |      is_integer : Check if the Index only consists of integers.
 |      is_floating : Check if the Index is a floating type.
 |      is_numeric : Check if the Index only consists of numeric data.
 |      is_categorical : Check if the Index holds categorical data.
 |      is_interval : Check if the Index holds Interval objects.
 |      is_mixed : Check if the Index holds data with mixed data types.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index(["Apple", "Mango", "Watermelon"])
 |      >>> idx.is_object()
 |      True
 |
 |      >>> idx = pd.Index(["Apple", "Mango", 2.0])
 |      >>> idx.is_object()
 |      True
 |
 |      >>> idx = pd.Index(["Watermelon", "Orange", "Apple",
 |      ...                 "Watermelon"]).astype("category")
 |      >>> idx.is_object()
 |      False
 |
 |      >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])
 |      >>> idx.is_object()
 |      False
 |
 |  is_type_compatible(self, kind: 'str_t') -> 'bool'
 |      Whether the index type is compatible with the provided type.
 |
 |  isin(self, values, level=None) -> 'npt.NDArray[np.bool_]'
 |      Return a boolean array where the index values are in `values`.
 |
 |      Compute boolean array of whether each index value is found in the
 |      passed set of values. The length of the returned boolean array matches
 |      the length of the index.
 |
 |      Parameters
 |      ----------
 |      values : set or list-like
 |          Sought values.
 |      level : str or int, optional
 |          Name or position of the index level to use (if the index is a
 |          `MultiIndex`).
 |
 |      Returns
 |      -------
 |      np.ndarray[bool]
 |          NumPy array of boolean values.
 |
 |      See Also
 |      --------
 |      Series.isin : Same for Series.
 |      DataFrame.isin : Same method for DataFrames.
 |
 |      Notes
 |      -----
 |      In the case of `MultiIndex` you must either specify `values` as a
 |      list-like object containing tuples that are the same length as the
 |      number of levels, or specify `level`. Otherwise it will raise a
 |      ``ValueError``.
 |
 |      If `level` is specified:
 |
 |      - if it is the name of one *and only one* index level, use that level;
 |      - otherwise it should be a number indicating level position.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([1,2,3])
 |      >>> idx
 |      Int64Index([1, 2, 3], dtype='int64')
 |
 |      Check whether each index value in a list of values.
 |
 |      >>> idx.isin([1, 4])
 |      array([ True, False, False])
 |
 |      >>> midx = pd.MultiIndex.from_arrays([[1,2,3],
 |      ...                                  ['red', 'blue', 'green']],
 |      ...                                  names=('number', 'color'))
 |      >>> midx
 |      MultiIndex([(1,   'red'),
 |                  (2,  'blue'),
 |                  (3, 'green')],
 |                 names=['number', 'color'])
 |
 |      Check whether the strings in the 'color' level of the MultiIndex
 |      are in a list of colors.
 |
 |      >>> midx.isin(['red', 'orange', 'yellow'], level='color')
 |      array([ True, False, False])
 |
 |      To check across the levels of a MultiIndex, pass a list of tuples:
 |
 |      >>> midx.isin([(1, 'red'), (3, 'red')])
 |      array([ True, False, False])
 |
 |      For a DatetimeIndex, string values in `values` are converted to
 |      Timestamps.
 |
 |      >>> dates = ['2000-03-11', '2000-03-12', '2000-03-13']
 |      >>> dti = pd.to_datetime(dates)
 |      >>> dti
 |      DatetimeIndex(['2000-03-11', '2000-03-12', '2000-03-13'],
 |      dtype='datetime64[ns]', freq=None)
 |
 |      >>> dti.isin(['2000-03-11'])
 |      array([ True, False, False])
 |
 |  isna(self) -> 'npt.NDArray[np.bool_]'
 |      Detect missing values.
 |
 |      Return a boolean same-sized object indicating if the values are NA.
 |      NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get
 |      mapped to ``True`` values.
 |      Everything else get mapped to ``False`` values. Characters such as
 |      empty strings `''` or :attr:`numpy.inf` are not considered NA values
 |      (unless you set ``pandas.options.mode.use_inf_as_na = True``).
 |
 |      Returns
 |      -------
 |      numpy.ndarray[bool]
 |          A boolean array of whether my values are NA.
 |
 |      See Also
 |      --------
 |      Index.notna : Boolean inverse of isna.
 |      Index.dropna : Omit entries with missing values.
 |      isna : Top-level isna.
 |      Series.isna : Detect missing values in Series object.
 |
 |      Examples
 |      --------
 |      Show which entries in a pandas.Index are NA. The result is an
 |      array.
 |
 |      >>> idx = pd.Index([5.2, 6.0, np.NaN])
 |      >>> idx
 |      Float64Index([5.2, 6.0, nan], dtype='float64')
 |      >>> idx.isna()
 |      array([False, False,  True])
 |
 |      Empty strings are not considered NA values. None is considered an NA
 |      value.
 |
 |      >>> idx = pd.Index(['black', '', 'red', None])
 |      >>> idx
 |      Index(['black', '', 'red', None], dtype='object')
 |      >>> idx.isna()
 |      array([False, False, False,  True])
 |
 |      For datetimes, `NaT` (Not a Time) is considered as an NA value.
 |
 |      >>> idx = pd.DatetimeIndex([pd.Timestamp('1940-04-25'),
 |      ...                         pd.Timestamp(''), None, pd.NaT])
 |      >>> idx
 |      DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],
 |                    dtype='datetime64[ns]', freq=None)
 |      >>> idx.isna()
 |      array([False,  True,  True,  True])
 |
 |  isnull = isna(self) -> 'npt.NDArray[np.bool_]'
 |
 |  join(self, other: 'Index', *, how: 'str_t' = 'left', level: 'Level' = None, return_indexers: 'bool' = False, sort: 'bool' = False) -> 'Index | tuple[Index, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None]'
 |      Compute join_index and indexers to conform data structures to the new index.
 |
 |      Parameters
 |      ----------
 |      other : Index
 |      how : {'left', 'right', 'inner', 'outer'}
 |      level : int or level name, default None
 |      return_indexers : bool, default False
 |      sort : bool, default False
 |          Sort the join keys lexicographically in the result Index. If False,
 |          the order of the join keys depends on the join type (how keyword).
 |
 |      Returns
 |      -------
 |      join_index, (left_indexer, right_indexer)
 |
 |  map(self, mapper, na_action=None)
 |      Map values using an input mapping or function.
 |
 |      Parameters
 |      ----------
 |      mapper : function, dict, or Series
 |          Mapping correspondence.
 |      na_action : {None, 'ignore'}
 |          If 'ignore', propagate NA values, without passing them to the
 |          mapping correspondence.
 |
 |      Returns
 |      -------
 |      applied : Union[Index, MultiIndex], inferred
 |          The output of the mapping function applied to the index.
 |          If the function returns a tuple with more than one element
 |          a MultiIndex will be returned.
 |
 |  max(self, axis=None, skipna=True, *args, **kwargs)
 |      Return the maximum value of the Index.
 |
 |      Parameters
 |      ----------
 |      axis : int, optional
 |          For compatibility with NumPy. Only 0 or None are allowed.
 |      skipna : bool, default True
 |          Exclude NA/null values when showing the result.
 |      *args, **kwargs
 |          Additional arguments and keywords for compatibility with NumPy.
 |
 |      Returns
 |      -------
 |      scalar
 |          Maximum value.
 |
 |      See Also
 |      --------
 |      Index.min : Return the minimum value in an Index.
 |      Series.max : Return the maximum value in a Series.
 |      DataFrame.max : Return the maximum values in a DataFrame.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([3, 2, 1])
 |      >>> idx.max()
 |      3
 |
 |      >>> idx = pd.Index(['c', 'b', 'a'])
 |      >>> idx.max()
 |      'c'
 |
 |      For a MultiIndex, the maximum is determined lexicographically.
 |
 |      >>> idx = pd.MultiIndex.from_product([('a', 'b'), (2, 1)])
 |      >>> idx.max()
 |      ('b', 2)
 |
 |  memory_usage(self, deep: 'bool' = False) -> 'int'
 |      Memory usage of the values.
 |
 |      Parameters
 |      ----------
 |      deep : bool, default False
 |          Introspect the data deeply, interrogate
 |          `object` dtypes for system-level memory consumption.
 |
 |      Returns
 |      -------
 |      bytes used
 |
 |      See Also
 |      --------
 |      numpy.ndarray.nbytes : Total bytes consumed by the elements of the
 |          array.
 |
 |      Notes
 |      -----
 |      Memory usage does not include memory consumed by elements that
 |      are not components of the array if deep=False or if used on PyPy
 |
 |  min(self, axis=None, skipna=True, *args, **kwargs)
 |      Return the minimum value of the Index.
 |
 |      Parameters
 |      ----------
 |      axis : {None}
 |          Dummy argument for consistency with Series.
 |      skipna : bool, default True
 |          Exclude NA/null values when showing the result.
 |      *args, **kwargs
 |          Additional arguments and keywords for compatibility with NumPy.
 |
 |      Returns
 |      -------
 |      scalar
 |          Minimum value.
 |
 |      See Also
 |      --------
 |      Index.max : Return the maximum value of the object.
 |      Series.min : Return the minimum value in a Series.
 |      DataFrame.min : Return the minimum values in a DataFrame.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([3, 2, 1])
 |      >>> idx.min()
 |      1
 |
 |      >>> idx = pd.Index(['c', 'b', 'a'])
 |      >>> idx.min()
 |      'a'
 |
 |      For a MultiIndex, the minimum is determined lexicographically.
 |
 |      >>> idx = pd.MultiIndex.from_product([('a', 'b'), (2, 1)])
 |      >>> idx.min()
 |      ('a', 1)
 |
 |  notna(self) -> 'npt.NDArray[np.bool_]'
 |      Detect existing (non-missing) values.
 |
 |      Return a boolean same-sized object indicating if the values are not NA.
 |      Non-missing values get mapped to ``True``. Characters such as empty
 |      strings ``''`` or :attr:`numpy.inf` are not considered NA values
 |      (unless you set ``pandas.options.mode.use_inf_as_na = True``).
 |      NA values, such as None or :attr:`numpy.NaN`, get mapped to ``False``
 |      values.
 |
 |      Returns
 |      -------
 |      numpy.ndarray[bool]
 |          Boolean array to indicate which entries are not NA.
 |
 |      See Also
 |      --------
 |      Index.notnull : Alias of notna.
 |      Index.isna: Inverse of notna.
 |      notna : Top-level notna.
 |
 |      Examples
 |      --------
 |      Show which entries in an Index are not NA. The result is an
 |      array.
 |
 |      >>> idx = pd.Index([5.2, 6.0, np.NaN])
 |      >>> idx
 |      Float64Index([5.2, 6.0, nan], dtype='float64')
 |      >>> idx.notna()
 |      array([ True,  True, False])
 |
 |      Empty strings are not considered NA values. None is considered a NA
 |      value.
 |
 |      >>> idx = pd.Index(['black', '', 'red', None])
 |      >>> idx
 |      Index(['black', '', 'red', None], dtype='object')
 |      >>> idx.notna()
 |      array([ True,  True,  True, False])
 |
 |  notnull = notna(self) -> 'npt.NDArray[np.bool_]'
 |
 |  putmask(self, mask, value) -> 'Index'
 |      Return a new Index of the values set with the mask.
 |
 |      Returns
 |      -------
 |      Index
 |
 |      See Also
 |      --------
 |      numpy.ndarray.putmask : Changes elements of an array
 |          based on conditional and input values.
 |
 |  ravel(self, order='C')
 |      Return an ndarray of the flattened values of the underlying data.
 |
 |      Returns
 |      -------
 |      numpy.ndarray
 |          Flattened array.
 |
 |      See Also
 |      --------
 |      numpy.ndarray.ravel : Return a flattened array.
 |
 |  reindex(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[Index, npt.NDArray[np.intp] | None]'
 |      Create index with target's values.
 |
 |      Parameters
 |      ----------
 |      target : an iterable
 |      method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
 |          * default: exact matches only.
 |          * pad / ffill: find the PREVIOUS index value if no exact match.
 |          * backfill / bfill: use NEXT index value if no exact match
 |          * nearest: use the NEAREST index value if no exact match. Tied
 |            distances are broken by preferring the larger index value.
 |      level : int, optional
 |          Level of multiindex.
 |      limit : int, optional
 |          Maximum number of consecutive labels in ``target`` to match for
 |          inexact matches.
 |      tolerance : int or float, optional
 |          Maximum distance between original and new labels for inexact
 |          matches. The values of the index at the matching locations must
 |          satisfy the equation ``abs(index[indexer] - target) <= tolerance``.
 |
 |          Tolerance may be a scalar value, which applies the same tolerance
 |          to all values, or list-like, which applies variable tolerance per
 |          element. List-like includes list, tuple, array, Series, and must be
 |          the same size as the index and its dtype must exactly match the
 |          index's type.
 |
 |      Returns
 |      -------
 |      new_index : pd.Index
 |          Resulting index.
 |      indexer : np.ndarray[np.intp] or None
 |          Indices of output values in original index.
 |
 |      Raises
 |      ------
 |      TypeError
 |          If ``method`` passed along with ``level``.
 |      ValueError
 |          If non-unique multi-index
 |      ValueError
 |          If non-unique index and ``method`` or ``limit`` passed.
 |
 |      See Also
 |      --------
 |      Series.reindex : Conform Series to new index with optional filling logic.
 |      DataFrame.reindex : Conform DataFrame to new index with optional filling logic.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index(['car', 'bike', 'train', 'tractor'])
 |      >>> idx
 |      Index(['car', 'bike', 'train', 'tractor'], dtype='object')
 |      >>> idx.reindex(['car', 'bike'])
 |      (Index(['car', 'bike'], dtype='object'), array([0, 1]))
 |
 |  rename(self, name, inplace=False)
 |      Alter Index or MultiIndex name.
 |
 |      Able to set new names without level. Defaults to returning new index.
 |      Length of names must match number of levels in MultiIndex.
 |
 |      Parameters
 |      ----------
 |      name : label or list of labels
 |          Name(s) to set.
 |      inplace : bool, default False
 |          Modifies the object directly, instead of creating a new Index or
 |          MultiIndex.
 |
 |      Returns
 |      -------
 |      Index or None
 |          The same type as the caller or None if ``inplace=True``.
 |
 |      See Also
 |      --------
 |      Index.set_names : Able to set new names partially and by level.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index(['A', 'C', 'A', 'B'], name='score')
 |      >>> idx.rename('grade')
 |      Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')
 |
 |      >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],
 |      ...                                   [2018, 2019]],
 |      ...                                   names=['kind', 'year'])
 |      >>> idx
 |      MultiIndex([('python', 2018),
 |                  ('python', 2019),
 |                  ( 'cobra', 2018),
 |                  ( 'cobra', 2019)],
 |                 names=['kind', 'year'])
 |      >>> idx.rename(['species', 'year'])
 |      MultiIndex([('python', 2018),
 |                  ('python', 2019),
 |                  ( 'cobra', 2018),
 |                  ( 'cobra', 2019)],
 |                 names=['species', 'year'])
 |      >>> idx.rename('species')
 |      Traceback (most recent call last):
 |      TypeError: Must pass list-like as `names`.
 |
 |  repeat(self, repeats, axis=None)
 |      Repeat elements of a Index.
 |
 |      Returns a new Index where each element of the current Index
 |      is repeated consecutively a given number of times.
 |
 |      Parameters
 |      ----------
 |      repeats : int or array of ints
 |          The number of repetitions for each element. This should be a
 |          non-negative integer. Repeating 0 times will return an empty
 |          Index.
 |      axis : None
 |          Must be ``None``. Has no effect but is accepted for compatibility
 |          with numpy.
 |
 |      Returns
 |      -------
 |      repeated_index : Index
 |          Newly created Index with repeated elements.
 |
 |      See Also
 |      --------
 |      Series.repeat : Equivalent function for Series.
 |      numpy.repeat : Similar method for :class:`numpy.ndarray`.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index(['a', 'b', 'c'])
 |      >>> idx
 |      Index(['a', 'b', 'c'], dtype='object')
 |      >>> idx.repeat(2)
 |      Index(['a', 'a', 'b', 'b', 'c', 'c'], dtype='object')
 |      >>> idx.repeat([1, 2, 3])
 |      Index(['a', 'b', 'b', 'c', 'c', 'c'], dtype='object')
 |
 |  set_names(self, names, *, level=None, inplace: 'bool' = False)
 |      Set Index or MultiIndex name.
 |
 |      Able to set new names partially and by level.
 |
 |      Parameters
 |      ----------
 |
 |      names : label or list of label or dict-like for MultiIndex
 |          Name(s) to set.
 |
 |          .. versionchanged:: 1.3.0
 |
 |      level : int, label or list of int or label, optional
 |          If the index is a MultiIndex and names is not dict-like, level(s) to set
 |          (None for all levels). Otherwise level must be None.
 |
 |          .. versionchanged:: 1.3.0
 |
 |      inplace : bool, default False
 |          Modifies the object directly, instead of creating a new Index or
 |          MultiIndex.
 |
 |      Returns
 |      -------
 |      Index or None
 |          The same type as the caller or None if ``inplace=True``.
 |
 |      See Also
 |      --------
 |      Index.rename : Able to set new names without level.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([1, 2, 3, 4])
 |      >>> idx
 |      Int64Index([1, 2, 3, 4], dtype='int64')
 |      >>> idx.set_names('quarter')
 |      Int64Index([1, 2, 3, 4], dtype='int64', name='quarter')
 |
 |      >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],
 |      ...                                   [2018, 2019]])
 |      >>> idx
 |      MultiIndex([('python', 2018),
 |                  ('python', 2019),
 |                  ( 'cobra', 2018),
 |                  ( 'cobra', 2019)],
 |                 )
 |      >>> idx.set_names(['kind', 'year'], inplace=True)
 |      >>> idx
 |      MultiIndex([('python', 2018),
 |                  ('python', 2019),
 |                  ( 'cobra', 2018),
 |                  ( 'cobra', 2019)],
 |                 names=['kind', 'year'])
 |      >>> idx.set_names('species', level=0)
 |      MultiIndex([('python', 2018),
 |                  ('python', 2019),
 |                  ( 'cobra', 2018),
 |                  ( 'cobra', 2019)],
 |                 names=['species', 'year'])
 |
 |      When renaming levels with a dict, levels can not be passed.
 |
 |      >>> idx.set_names({'kind': 'snake'})
 |      MultiIndex([('python', 2018),
 |                  ('python', 2019),
 |                  ( 'cobra', 2018),
 |                  ( 'cobra', 2019)],
 |                 names=['snake', 'year'])
 |
 |  set_value(self, arr, key, value) -> 'None'
 |      Fast lookup of value from 1-dimensional ndarray.
 |
 |      .. deprecated:: 1.0
 |
 |      Notes
 |      -----
 |      Only use this if you know what you're doing.
 |
 |  shift(self, periods=1, freq=None)
 |      Shift index by desired number of time frequency increments.
 |
 |      This method is for shifting the values of datetime-like indexes
 |      by a specified time increment a given number of times.
 |
 |      Parameters
 |      ----------
 |      periods : int, default 1
 |          Number of periods (or increments) to shift by,
 |          can be positive or negative.
 |      freq : pandas.DateOffset, pandas.Timedelta or str, optional
 |          Frequency increment to shift by.
 |          If None, the index is shifted by its own `freq` attribute.
 |          Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc.
 |
 |      Returns
 |      -------
 |      pandas.Index
 |          Shifted index.
 |
 |      See Also
 |      --------
 |      Series.shift : Shift values of Series.
 |
 |      Notes
 |      -----
 |      This method is only implemented for datetime-like index classes,
 |      i.e., DatetimeIndex, PeriodIndex and TimedeltaIndex.
 |
 |      Examples
 |      --------
 |      Put the first 5 month starts of 2011 into an index.
 |
 |      >>> month_starts = pd.date_range('1/1/2011', periods=5, freq='MS')
 |      >>> month_starts
 |      DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01', '2011-04-01',
 |                     '2011-05-01'],
 |                    dtype='datetime64[ns]', freq='MS')
 |
 |      Shift the index by 10 days.
 |
 |      >>> month_starts.shift(10, freq='D')
 |      DatetimeIndex(['2011-01-11', '2011-02-11', '2011-03-11', '2011-04-11',
 |                     '2011-05-11'],
 |                    dtype='datetime64[ns]', freq=None)
 |
 |      The default value of `freq` is the `freq` attribute of the index,
 |      which is 'MS' (month start) in this example.
 |
 |      >>> month_starts.shift(10)
 |      DatetimeIndex(['2011-11-01', '2011-12-01', '2012-01-01', '2012-02-01',
 |                     '2012-03-01'],
 |                    dtype='datetime64[ns]', freq='MS')
 |
 |  slice_indexer(self, start: 'Hashable | None' = None, end: 'Hashable | None' = None, step: 'int | None' = None, kind=<no_default>) -> 'slice'
 |      Compute the slice indexer for input labels and step.
 |
 |      Index needs to be ordered and unique.
 |
 |      Parameters
 |      ----------
 |      start : label, default None
 |          If None, defaults to the beginning.
 |      end : label, default None
 |          If None, defaults to the end.
 |      step : int, default None
 |      kind : str, default None
 |
 |          .. deprecated:: 1.4.0
 |
 |      Returns
 |      -------
 |      indexer : slice
 |
 |      Raises
 |      ------
 |      KeyError : If key does not exist, or key is not unique and index is
 |          not ordered.
 |
 |      Notes
 |      -----
 |      This function assumes that the data is sorted, so use at your own peril
 |
 |      Examples
 |      --------
 |      This is a method on all index types. For example you can do:
 |
 |      >>> idx = pd.Index(list('abcd'))
 |      >>> idx.slice_indexer(start='b', end='c')
 |      slice(1, 3, None)
 |
 |      >>> idx = pd.MultiIndex.from_arrays([list('abcd'), list('efgh')])
 |      >>> idx.slice_indexer(start='b', end=('c', 'g'))
 |      slice(1, 3, None)
 |
 |  slice_locs(self, start=None, end=None, step=None, kind=<no_default>) -> 'tuple[int, int]'
 |      Compute slice locations for input labels.
 |
 |      Parameters
 |      ----------
 |      start : label, default None
 |          If None, defaults to the beginning.
 |      end : label, default None
 |          If None, defaults to the end.
 |      step : int, defaults None
 |          If None, defaults to 1.
 |      kind : {'loc', 'getitem'} or None
 |
 |          .. deprecated:: 1.4.0
 |
 |      Returns
 |      -------
 |      start, end : int
 |
 |      See Also
 |      --------
 |      Index.get_loc : Get location for a single label.
 |
 |      Notes
 |      -----
 |      This method only works if the index is monotonic or unique.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index(list('abcd'))
 |      >>> idx.slice_locs(start='b', end='c')
 |      (1, 3)
 |
 |  sort(self, *args, **kwargs)
 |      Use sort_values instead.
 |
 |  sort_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'last', key: 'Callable | None' = None)
 |      Return a sorted copy of the index.
 |
 |      Return a sorted copy of the index, and optionally return the indices
 |      that sorted the index itself.
 |
 |      Parameters
 |      ----------
 |      return_indexer : bool, default False
 |          Should the indices that would sort the index be returned.
 |      ascending : bool, default True
 |          Should the index values be sorted in an ascending order.
 |      na_position : {'first' or 'last'}, default 'last'
 |          Argument 'first' puts NaNs at the beginning, 'last' puts NaNs at
 |          the end.
 |
 |          .. versionadded:: 1.2.0
 |
 |      key : callable, optional
 |          If not None, apply the key function to the index values
 |          before sorting. This is similar to the `key` argument in the
 |          builtin :meth:`sorted` function, with the notable difference that
 |          this `key` function should be *vectorized*. It should expect an
 |          ``Index`` and return an ``Index`` of the same shape.
 |
 |          .. versionadded:: 1.1.0
 |
 |      Returns
 |      -------
 |      sorted_index : pandas.Index
 |          Sorted copy of the index.
 |      indexer : numpy.ndarray, optional
 |          The indices that the index itself was sorted by.
 |
 |      See Also
 |      --------
 |      Series.sort_values : Sort values of a Series.
 |      DataFrame.sort_values : Sort values in a DataFrame.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([10, 100, 1, 1000])
 |      >>> idx
 |      Int64Index([10, 100, 1, 1000], dtype='int64')
 |
 |      Sort values in ascending order (default behavior).
 |
 |      >>> idx.sort_values()
 |      Int64Index([1, 10, 100, 1000], dtype='int64')
 |
 |      Sort values in descending order, and also get the indices `idx` was
 |      sorted by.
 |
 |      >>> idx.sort_values(ascending=False, return_indexer=True)
 |      (Int64Index([1000, 100, 10, 1], dtype='int64'), array([3, 1, 0, 2]))
 |
 |  sortlevel(self, level=None, ascending=True, sort_remaining=None)
 |      For internal compatibility with the Index API.
 |
 |      Sort the Index. This is for compat with MultiIndex
 |
 |      Parameters
 |      ----------
 |      ascending : bool, default True
 |          False to sort in descending order
 |
 |      level, sort_remaining are compat parameters
 |
 |      Returns
 |      -------
 |      Index
 |
 |  symmetric_difference(self, other, result_name=None, sort=None)
 |      Compute the symmetric difference of two Index objects.
 |
 |      Parameters
 |      ----------
 |      other : Index or array-like
 |      result_name : str
 |      sort : False or None, default None
 |          Whether to sort the resulting index. By default, the
 |          values are attempted to be sorted, but any TypeError from
 |          incomparable elements is caught by pandas.
 |
 |          * None : Attempt to sort the result, but catch any TypeErrors
 |            from comparing incomparable elements.
 |          * False : Do not sort the result.
 |
 |      Returns
 |      -------
 |      symmetric_difference : Index
 |
 |      Notes
 |      -----
 |      ``symmetric_difference`` contains elements that appear in either
 |      ``idx1`` or ``idx2`` but not both. Equivalent to the Index created by
 |      ``idx1.difference(idx2) | idx2.difference(idx1)`` with duplicates
 |      dropped.
 |
 |      Examples
 |      --------
 |      >>> idx1 = pd.Index([1, 2, 3, 4])
 |      >>> idx2 = pd.Index([2, 3, 4, 5])
 |      >>> idx1.symmetric_difference(idx2)
 |      Int64Index([1, 5], dtype='int64')
 |
 |  take(self, indices, axis: 'int' = 0, allow_fill: 'bool' = True, fill_value=None, **kwargs)
 |      Return a new Index of the values selected by the indices.
 |
 |      For internal compatibility with numpy arrays.
 |
 |      Parameters
 |      ----------
 |      indices : array-like
 |          Indices to be taken.
 |      axis : int, optional
 |          The axis over which to select values, always 0.
 |      allow_fill : bool, default True
 |      fill_value : scalar, default None
 |          If allow_fill=True and fill_value is not None, indices specified by
 |          -1 are regarded as NA. If Index doesn't hold NA, raise ValueError.
 |
 |      Returns
 |      -------
 |      Index
 |          An index formed of elements at the given indices. Will be the same
 |          type as self, except for RangeIndex.
 |
 |      See Also
 |      --------
 |      numpy.ndarray.take: Return an array formed from the
 |          elements of a at the given indices.
 |
 |  to_flat_index(self: '_IndexT') -> '_IndexT'
 |      Identity method.
 |
 |      This is implemented for compatibility with subclass implementations
 |      when chaining.
 |
 |      Returns
 |      -------
 |      pd.Index
 |          Caller.
 |
 |      See Also
 |      --------
 |      MultiIndex.to_flat_index : Subclass implementation.
 |
 |  to_frame(self, index: 'bool' = True, name: 'Hashable' = <no_default>) -> 'DataFrame'
 |      Create a DataFrame with a column containing the Index.
 |
 |      Parameters
 |      ----------
 |      index : bool, default True
 |          Set the index of the returned DataFrame as the original Index.
 |
 |      name : object, default None
 |          The passed name should substitute for the index name (if it has
 |          one).
 |
 |      Returns
 |      -------
 |      DataFrame
 |          DataFrame containing the original Index data.
 |
 |      See Also
 |      --------
 |      Index.to_series : Convert an Index to a Series.
 |      Series.to_frame : Convert Series to DataFrame.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index(['Ant', 'Bear', 'Cow'], name='animal')
 |      >>> idx.to_frame()
 |             animal
 |      animal
 |      Ant       Ant
 |      Bear     Bear
 |      Cow       Cow
 |
 |      By default, the original Index is reused. To enforce a new Index:
 |
 |      >>> idx.to_frame(index=False)
 |          animal
 |      0   Ant
 |      1  Bear
 |      2   Cow
 |
 |      To override the name of the resulting column, specify `name`:
 |
 |      >>> idx.to_frame(index=False, name='zoo')
 |          zoo
 |      0   Ant
 |      1  Bear
 |      2   Cow
 |
 |  to_native_types(self, slicer=None, **kwargs) -> 'np.ndarray'
 |      Format specified values of `self` and return them.
 |
 |      .. deprecated:: 1.2.0
 |
 |      Parameters
 |      ----------
 |      slicer : int, array-like
 |          An indexer into `self` that specifies which values
 |          are used in the formatting process.
 |      kwargs : dict
 |          Options for specifying how the values should be formatted.
 |          These options include the following:
 |
 |          1) na_rep : str
 |              The value that serves as a placeholder for NULL values
 |          2) quoting : bool or None
 |              Whether or not there are quoted values in `self`
 |          3) date_format : str
 |              The format used to represent date-like values.
 |
 |      Returns
 |      -------
 |      numpy.ndarray
 |          Formatted values.
 |
 |  to_series(self, index=None, name: 'Hashable' = None) -> 'Series'
 |      Create a Series with both index and values equal to the index keys.
 |
 |      Useful with map for returning an indexer based on an index.
 |
 |      Parameters
 |      ----------
 |      index : Index, optional
 |          Index of resulting Series. If None, defaults to original index.
 |      name : str, optional
 |          Name of resulting Series. If None, defaults to name of original
 |          index.
 |
 |      Returns
 |      -------
 |      Series
 |          The dtype will be based on the type of the Index values.
 |
 |      See Also
 |      --------
 |      Index.to_frame : Convert an Index to a DataFrame.
 |      Series.to_frame : Convert Series to DataFrame.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index(['Ant', 'Bear', 'Cow'], name='animal')
 |
 |      By default, the original Index and original name is reused.
 |
 |      >>> idx.to_series()
 |      animal
 |      Ant      Ant
 |      Bear    Bear
 |      Cow      Cow
 |      Name: animal, dtype: object
 |
 |      To enforce a new Index, specify new labels to ``index``:
 |
 |      >>> idx.to_series(index=[0, 1, 2])
 |      0     Ant
 |      1    Bear
 |      2     Cow
 |      Name: animal, dtype: object
 |
 |      To override the name of the resulting column, specify `name`:
 |
 |      >>> idx.to_series(name='zoo')
 |      animal
 |      Ant      Ant
 |      Bear    Bear
 |      Cow      Cow
 |      Name: zoo, dtype: object
 |
 |  union(self, other, sort=None)
 |      Form the union of two Index objects.
 |
 |      If the Index objects are incompatible, both Index objects will be
 |      cast to dtype('object') first.
 |
 |          .. versionchanged:: 0.25.0
 |
 |      Parameters
 |      ----------
 |      other : Index or array-like
 |      sort : bool or None, default None
 |          Whether to sort the resulting Index.
 |
 |          * None : Sort the result, except when
 |
 |            1. `self` and `other` are equal.
 |            2. `self` or `other` has length 0.
 |            3. Some values in `self` or `other` cannot be compared.
 |               A RuntimeWarning is issued in this case.
 |
 |          * False : do not sort the result.
 |
 |      Returns
 |      -------
 |      union : Index
 |
 |      Examples
 |      --------
 |      Union matching dtypes
 |
 |      >>> idx1 = pd.Index([1, 2, 3, 4])
 |      >>> idx2 = pd.Index([3, 4, 5, 6])
 |      >>> idx1.union(idx2)
 |      Int64Index([1, 2, 3, 4, 5, 6], dtype='int64')
 |
 |      Union mismatched dtypes
 |
 |      >>> idx1 = pd.Index(['a', 'b', 'c', 'd'])
 |      >>> idx2 = pd.Index([1, 2, 3, 4])
 |      >>> idx1.union(idx2)
 |      Index(['a', 'b', 'c', 'd', 1, 2, 3, 4], dtype='object')
 |
 |      MultiIndex case
 |
 |      >>> idx1 = pd.MultiIndex.from_arrays(
 |      ...     [[1, 1, 2, 2], ["Red", "Blue", "Red", "Blue"]]
 |      ... )
 |      >>> idx1
 |      MultiIndex([(1,  'Red'),
 |          (1, 'Blue'),
 |          (2,  'Red'),
 |          (2, 'Blue')],
 |         )
 |      >>> idx2 = pd.MultiIndex.from_arrays(
 |      ...     [[3, 3, 2, 2], ["Red", "Green", "Red", "Green"]]
 |      ... )
 |      >>> idx2
 |      MultiIndex([(3,   'Red'),
 |          (3, 'Green'),
 |          (2,   'Red'),
 |          (2, 'Green')],
 |         )
 |      >>> idx1.union(idx2)
 |      MultiIndex([(1,  'Blue'),
 |          (1,   'Red'),
 |          (2,  'Blue'),
 |          (2, 'Green'),
 |          (2,   'Red'),
 |          (3, 'Green'),
 |          (3,   'Red')],
 |         )
 |      >>> idx1.union(idx2, sort=False)
 |      MultiIndex([(1,   'Red'),
 |          (1,  'Blue'),
 |          (2,   'Red'),
 |          (2,  'Blue'),
 |          (3,   'Red'),
 |          (3, 'Green'),
 |          (2, 'Green')],
 |         )
 |
 |  unique(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT'
 |      Return unique values in the index.
 |
 |      Unique values are returned in order of appearance, this does NOT sort.
 |
 |      Parameters
 |      ----------
 |      level : int or hashable, optional
 |          Only return values from specified level (for MultiIndex).
 |          If int, gets the level by integer position, else by level name.
 |
 |      Returns
 |      -------
 |      Index
 |
 |      See Also
 |      --------
 |      unique : Numpy array of unique values in that column.
 |      Series.unique : Return unique values of Series object.
 |
 |  view(self, cls=None)
 |
 |  where(self, cond, other=None) -> 'Index'
 |      Replace values where the condition is False.
 |
 |      The replacement is taken from other.
 |
 |      Parameters
 |      ----------
 |      cond : bool array-like with the same length as self
 |          Condition to select the values on.
 |      other : scalar, or array-like, default None
 |          Replacement if the condition is False.
 |
 |      Returns
 |      -------
 |      pandas.Index
 |          A copy of self with values replaced from other
 |          where the condition is False.
 |
 |      See Also
 |      --------
 |      Series.where : Same method for Series.
 |      DataFrame.where : Same method for DataFrame.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index(['car', 'bike', 'train', 'tractor'])
 |      >>> idx
 |      Index(['car', 'bike', 'train', 'tractor'], dtype='object')
 |      >>> idx.where(idx.isin(['car', 'train']), 'other')
 |      Index(['car', 'other', 'train', 'other'], dtype='object')
 |
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |
 |  __new__(cls, data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index'
 |      Create and return a new object.  See help(type) for accurate signature.
 |
 |  ----------------------------------------------------------------------
 |  Readonly properties defined here:
 |
 |  asi8
 |      Integer representation of the values.
 |
 |      Returns
 |      -------
 |      ndarray
 |          An ndarray with int64 dtype.
 |
 |  has_duplicates
 |      Check if the Index has duplicate values.
 |
 |      Returns
 |      -------
 |      bool
 |          Whether or not the Index has duplicate values.
 |
 |      Examples
 |      --------
 |      >>> idx = pd.Index([1, 5, 7, 7])
 |      >>> idx.has_duplicates
 |      True
 |
 |      >>> idx = pd.Index([1, 5, 7])
 |      >>> idx.has_duplicates
 |      False
 |
 |      >>> idx = pd.Index(["Watermelon", "Orange", "Apple",
 |      ...                 "Watermelon"]).astype("category")
 |      >>> idx.has_duplicates
 |      True
 |
 |      >>> idx = pd.Index(["Orange", "Apple",
 |      ...                 "Watermelon"]).astype("category")
 |      >>> idx.has_duplicates
 |      False
 |
 |  is_monotonic
 |      Alias for is_monotonic_increasing.
 |
 |      .. deprecated:: 1.5.0
 |          is_monotonic is deprecated and will be removed in a future version.
 |          Use is_monotonic_increasing instead.
 |
 |  is_monotonic_decreasing
 |      Return a boolean if the values are equal or decreasing.
 |
 |      Examples
 |      --------
 |      >>> Index([3, 2, 1]).is_monotonic_decreasing
 |      True
 |      >>> Index([3, 2, 2]).is_monotonic_decreasing
 |      True
 |      >>> Index([3, 1, 2]).is_monotonic_decreasing
 |      False
 |
 |  is_monotonic_increasing
 |      Return a boolean if the values are equal or increasing.
 |
 |      Examples
 |      --------
 |      >>> Index([1, 2, 3]).is_monotonic_increasing
 |      True
 |      >>> Index([1, 2, 2]).is_monotonic_increasing
 |      True
 |      >>> Index([1, 3, 2]).is_monotonic_increasing
 |      False
 |
 |  nlevels
 |      Number of levels.
 |
 |  shape
 |      Return a tuple of the shape of the underlying data.
 |
 |  values
 |      Return an array representing the data in the Index.
 |
 |      .. warning::
 |
 |         We recommend using :attr:`Index.array` or
 |         :meth:`Index.to_numpy`, depending on whether you need
 |         a reference to the underlying data or a NumPy array.
 |
 |      Returns
 |      -------
 |      array: numpy.ndarray or ExtensionArray
 |
 |      See Also
 |      --------
 |      Index.array : Reference to the underlying data.
 |      Index.to_numpy : A NumPy array representing the underlying data.
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |
 |  array
 |      The ExtensionArray of the data backing this Series or Index.
 |
 |      Returns
 |      -------
 |      ExtensionArray
 |          An ExtensionArray of the values stored within. For extension
 |          types, this is the actual array. For NumPy native types, this
 |          is a thin (no copy) wrapper around :class:`numpy.ndarray`.
 |
 |          ``.array`` differs ``.values`` which may require converting the
 |          data to a different form.
 |
 |      See Also
 |      --------
 |      Index.to_numpy : Similar method that always returns a NumPy array.
 |      Series.to_numpy : Similar method that always returns a NumPy array.
 |
 |      Notes
 |      -----
 |      This table lays out the different array types for each extension
 |      dtype within pandas.
 |
 |      ================== =============================
 |      dtype              array type
 |      ================== =============================
 |      category           Categorical
 |      period             PeriodArray
 |      interval           IntervalArray
 |      IntegerNA          IntegerArray
 |      string             StringArray
 |      boolean            BooleanArray
 |      datetime64[ns, tz] DatetimeArray
 |      ================== =============================
 |
 |      For any 3rd-party extension types, the array type will be an
 |      ExtensionArray.
 |
 |      For all remaining dtypes ``.array`` will be a
 |      :class:`arrays.NumpyExtensionArray` wrapping the actual ndarray
 |      stored within. If you absolutely need a NumPy array (possibly with
 |      copying / coercing data), then use :meth:`Series.to_numpy` instead.
 |
 |      Examples
 |      --------
 |      For regular NumPy types like int, and float, a PandasArray
 |      is returned.
 |
 |      >>> pd.Series([1, 2, 3]).array
 |      <PandasArray>
 |      [1, 2, 3]
 |      Length: 3, dtype: int64
 |
 |      For extension types, like Categorical, the actual ExtensionArray
 |      is returned
 |
 |      >>> ser = pd.Series(pd.Categorical(['a', 'b', 'a']))
 |      >>> ser.array
 |      ['a', 'b', 'a']
 |      Categories (2, object): ['a', 'b']
 |
 |  dtype
 |      Return the dtype object of the underlying data.
 |
 |  hasnans
 |      Return True if there are any NaNs.
 |
 |      Enables various performance speedups.
 |
 |  inferred_type
 |      Return a string of the type inferred from the values.
 |
 |  is_all_dates
 |      Whether or not the index values only consist of dates.
 |
 |  is_unique
 |      Return if the index has unique values.
 |
 |  name
 |      Return Index or MultiIndex name.
 |
 |  names
 |
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |
 |  __annotations__ = {'__hash__': 'ClassVar[None]', '_attributes': 'list[...
 |
 |  str = <class 'pandas.core.strings.accessor.StringMethods'>
 |      Vectorized string functions for Series and Index.
 |
 |      NAs stay NA unless handled otherwise by a particular method.
 |      Patterned after Python's string methods, with some inspiration from
 |      R's stringr package.
 |
 |      Examples
 |      --------
 |      >>> s = pd.Series(["A_Str_Series"])
 |      >>> s
 |      0    A_Str_Series
 |      dtype: object
 |
 |      >>> s.str.split("_")
 |      0    [A, Str, Series]
 |      dtype: object
 |
 |      >>> s.str.replace("_", "")
 |      0    AStrSeries
 |      dtype: object
 |
 |
 |  ----------------------------------------------------------------------
 |  Methods inherited from pandas.core.base.IndexOpsMixin:
 |
 |  __iter__(self)
 |      Return an iterator of the values.
 |
 |      These are each a scalar type, which is a Python scalar
 |      (for str, int, float) or a pandas scalar
 |      (for Timestamp/Timedelta/Interval/Period)
 |
 |      Returns
 |      -------
 |      iterator
 |
 |  factorize(self, sort: 'bool' = False, na_sentinel: 'int | lib.NoDefault' = <no_default>, use_na_sentinel: 'bool | lib.NoDefault' = <no_default>)
 |      Encode the object as an enumerated type or categorical variable.
 |
 |      This method is useful for obtaining a numeric representation of an
 |      array when all that matters is identifying distinct values. `factorize`
 |      is available as both a top-level function :func:`pandas.factorize`,
 |      and as a method :meth:`Series.factorize` and :meth:`Index.factorize`.
 |
 |      Parameters
 |      ----------
 |      sort : bool, default False
 |          Sort `uniques` and shuffle `codes` to maintain the
 |          relationship.
 |
 |      na_sentinel : int or None, default -1
 |          Value to mark "not found". If None, will not drop the NaN
 |          from the uniques of the values.
 |
 |          .. deprecated:: 1.5.0
 |              The na_sentinel argument is deprecated and
 |              will be removed in a future version of pandas. Specify use_na_sentinel as
 |              either True or False.
 |
 |          .. versionchanged:: 1.1.2
 |
 |      use_na_sentinel : bool, default True
 |          If True, the sentinel -1 will be used for NaN values. If False,
 |          NaN values will be encoded as non-negative integers and will not drop the
 |          NaN from the uniques of the values.
 |
 |          .. versionadded:: 1.5.0
 |
 |      Returns
 |      -------
 |      codes : ndarray
 |          An integer ndarray that's an indexer into `uniques`.
 |          ``uniques.take(codes)`` will have the same values as `values`.
 |      uniques : ndarray, Index, or Categorical
 |          The unique valid values. When `values` is Categorical, `uniques`
 |          is a Categorical. When `values` is some other pandas object, an
 |          `Index` is returned. Otherwise, a 1-D ndarray is returned.
 |
 |          .. note::
 |
 |             Even if there's a missing value in `values`, `uniques` will
 |             *not* contain an entry for it.
 |
 |      See Also
 |      --------
 |      cut : Discretize continuous-valued array.
 |      unique : Find the unique value in an array.
 |
 |      Notes
 |      -----
 |      Reference :ref:`the user guide <reshaping.factorize>` for more examples.
 |
 |      Examples
 |      --------
 |      These examples all show factorize as a top-level method like
 |      ``pd.factorize(values)``. The results are identical for methods like
 |      :meth:`Series.factorize`.
 |
 |      >>> codes, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b'])
 |      >>> codes
 |      array([0, 0, 1, 2, 0]...)
 |      >>> uniques
 |      array(['b', 'a', 'c'], dtype=object)
 |
 |      With ``sort=True``, the `uniques` will be sorted, and `codes` will be
 |      shuffled so that the relationship is the maintained.
 |
 |      >>> codes, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b'], sort=True)
 |      >>> codes
 |      array([1, 1, 0, 2, 1]...)
 |      >>> uniques
 |      array(['a', 'b', 'c'], dtype=object)
 |
 |      When ``use_na_sentinel=True`` (the default), missing values are indicated in
 |      the `codes` with the sentinel value ``-1`` and missing values are not
 |      included in `uniques`.
 |
 |      >>> codes, uniques = pd.factorize(['b', None, 'a', 'c', 'b'])
 |      >>> codes
 |      array([ 0, -1,  1,  2,  0]...)
 |      >>> uniques
 |      array(['b', 'a', 'c'], dtype=object)
 |
 |      Thus far, we've only factorized lists (which are internally coerced to
 |      NumPy arrays). When factorizing pandas objects, the type of `uniques`
 |      will differ. For Categoricals, a `Categorical` is returned.
 |
 |      >>> cat = pd.Categorical(['a', 'a', 'c'], categories=['a', 'b', 'c'])
 |      >>> codes, uniques = pd.factorize(cat)
 |      >>> codes
 |      array([0, 0, 1]...)
 |      >>> uniques
 |      ['a', 'c']
 |      Categories (3, object): ['a', 'b', 'c']
 |
 |      Notice that ``'b'`` is in ``uniques.categories``, despite not being
 |      present in ``cat.values``.
 |
 |      For all other pandas objects, an Index of the appropriate type is
 |      returned.
 |
 |      >>> cat = pd.Series(['a', 'a', 'c'])
 |      >>> codes, uniques = pd.factorize(cat)
 |      >>> codes
 |      array([0, 0, 1]...)
 |      >>> uniques
 |      Index(['a', 'c'], dtype='object')
 |
 |      If NaN is in the values, and we want to include NaN in the uniques of the
 |      values, it can be achieved by setting ``use_na_sentinel=False``.
 |
 |      >>> values = np.array([1, 2, 1, np.nan])
 |      >>> codes, uniques = pd.factorize(values)  # default: use_na_sentinel=True
 |      >>> codes
 |      array([ 0,  1,  0, -1])
 |      >>> uniques
 |      array([1., 2.])
 |
 |      >>> codes, uniques = pd.factorize(values, use_na_sentinel=False)
 |      >>> codes
 |      array([0, 1, 0, 2])
 |      >>> uniques
 |      array([ 1.,  2., nan])
 |
 |  item(self)
 |      Return the first element of the underlying data as a Python scalar.
 |
 |      Returns
 |      -------
 |      scalar
 |          The first element of %(klass)s.
 |
 |      Raises
 |      ------
 |      ValueError
 |          If the data is not length-1.
 |
 |  nunique(self, dropna: 'bool' = True) -> 'int'
 |      Return number of unique elements in the object.
 |
 |      Excludes NA values by default.
 |
 |      Parameters
 |      ----------
 |      dropna : bool, default True
 |          Don't include NaN in the count.
 |
 |      Returns
 |      -------
 |      int
 |
 |      See Also
 |      --------
 |      DataFrame.nunique: Method nunique for DataFrame.
 |      Series.count: Count non-NA/null observations in the Series.
 |
 |      Examples
 |      --------
 |      >>> s = pd.Series([1, 3, 5, 7, 7])
 |      >>> s
 |      0    1
 |      1    3
 |      2    5
 |      3    7
 |      4    7
 |      dtype: int64
 |
 |      >>> s.nunique()
 |      4
 |
 |  searchsorted(self, value: 'NumpyValueArrayLike | ExtensionArray', side: "Literal['left', 'right']" = 'left', sorter: 'NumpySorter' = None) -> 'npt.NDArray[np.intp] | np.intp'
 |      Find indices where elements should be inserted to maintain order.
 |
 |      Find the indices into a sorted Index `self` such that, if the
 |      corresponding elements in `value` were inserted before the indices,
 |      the order of `self` would be preserved.
 |
 |      .. note::
 |
 |          The Index *must* be monotonically sorted, otherwise
 |          wrong locations will likely be returned. Pandas does *not*
 |          check this for you.
 |
 |      Parameters
 |      ----------
 |      value : array-like or scalar
 |          Values to insert into `self`.
 |      side : {'left', 'right'}, optional
 |          If 'left', the index of the first suitable location found is given.
 |          If 'right', return the last such index.  If there is no suitable
 |          index, return either 0 or N (where N is the length of `self`).
 |      sorter : 1-D array-like, optional
 |          Optional array of integer indices that sort `self` into ascending
 |          order. They are typically the result of ``np.argsort``.
 |
 |      Returns
 |      -------
 |      int or array of int
 |          A scalar or array of insertion points with the
 |          same shape as `value`.
 |
 |      See Also
 |      --------
 |      sort_values : Sort by the values along either axis.
 |      numpy.searchsorted : Similar method from NumPy.
 |
 |      Notes
 |      -----
 |      Binary search is used to find the required insertion points.
 |
 |      Examples
 |      --------
 |      >>> ser = pd.Series([1, 2, 3])
 |      >>> ser
 |      0    1
 |      1    2
 |      2    3
 |      dtype: int64
 |
 |      >>> ser.searchsorted(4)
 |      3
 |
 |      >>> ser.searchsorted([0, 4])
 |      array([0, 3])
 |
 |      >>> ser.searchsorted([1, 3], side='left')
 |      array([0, 2])
 |
 |      >>> ser.searchsorted([1, 3], side='right')
 |      array([1, 3])
 |
 |      >>> ser = pd.Series(pd.to_datetime(['3/11/2000', '3/12/2000', '3/13/2000']))
 |      >>> ser
 |      0   2000-03-11
 |      1   2000-03-12
 |      2   2000-03-13
 |      dtype: datetime64[ns]
 |
 |      >>> ser.searchsorted('3/14/2000')
 |      3
 |
 |      >>> ser = pd.Categorical(
 |      ...     ['apple', 'bread', 'bread', 'cheese', 'milk'], ordered=True
 |      ... )
 |      >>> ser
 |      ['apple', 'bread', 'bread', 'cheese', 'milk']
 |      Categories (4, object): ['apple' < 'bread' < 'cheese' < 'milk']
 |
 |      >>> ser.searchsorted('bread')
 |      1
 |
 |      >>> ser.searchsorted(['bread'], side='right')
 |      array([3])
 |
 |      If the values are not monotonically sorted, wrong locations
 |      may be returned:
 |
 |      >>> ser = pd.Series([2, 1, 3])
 |      >>> ser
 |      0    2
 |      1    1
 |      2    3
 |      dtype: int64
 |
 |      >>> ser.searchsorted(1)  # doctest: +SKIP
 |      0  # wrong result, correct would be 1
 |
 |  to_list = tolist(self)
 |
 |  to_numpy(self, dtype: 'npt.DTypeLike | None' = None, copy: 'bool' = False, na_value: 'object' = <no_default>, **kwargs) -> 'np.ndarray'
 |      A NumPy ndarray representing the values in this Series or Index.
 |
 |      Parameters
 |      ----------
 |      dtype : str or numpy.dtype, optional
 |          The dtype to pass to :meth:`numpy.asarray`.
 |      copy : bool, default False
 |          Whether to ensure that the returned value is not a view on
 |          another array. Note that ``copy=False`` does not *ensure* that
 |          ``to_numpy()`` is no-copy. Rather, ``copy=True`` ensure that
 |          a copy is made, even if not strictly necessary.
 |      na_value : Any, optional
 |          The value to use for missing values. The default value depends
 |          on `dtype` and the type of the array.
 |
 |          .. versionadded:: 1.0.0
 |
 |      **kwargs
 |          Additional keywords passed through to the ``to_numpy`` method
 |          of the underlying array (for extension arrays).
 |
 |          .. versionadded:: 1.0.0
 |
 |      Returns
 |      -------
 |      numpy.ndarray
 |
 |      See Also
 |      --------
 |      Series.array : Get the actual data stored within.
 |      Index.array : Get the actual data stored within.
 |      DataFrame.to_numpy : Similar method for DataFrame.
 |
 |      Notes
 |      -----
 |      The returned array will be the same up to equality (values equal
 |      in `self` will be equal in the returned array; likewise for values
 |      that are not equal). When `self` contains an ExtensionArray, the
 |      dtype may be different. For example, for a category-dtype Series,
 |      ``to_numpy()`` will return a NumPy array and the categorical dtype
 |      will be lost.
 |
 |      For NumPy dtypes, this will be a reference to the actual data stored
 |      in this Series or Index (assuming ``copy=False``). Modifying the result
 |      in place will modify the data stored in the Series or Index (not that
 |      we recommend doing that).
 |
 |      For extension types, ``to_numpy()`` *may* require copying data and
 |      coercing the result to a NumPy type (possibly object), which may be
 |      expensive. When you need a no-copy reference to the underlying data,
 |      :attr:`Series.array` should be used instead.
 |
 |      This table lays out the different dtypes and default return types of
 |      ``to_numpy()`` for various dtypes within pandas.
 |
 |      ================== ================================
 |      dtype              array type
 |      ================== ================================
 |      category[T]        ndarray[T] (same dtype as input)
 |      period             ndarray[object] (Periods)
 |      interval           ndarray[object] (Intervals)
 |      IntegerNA          ndarray[object]
 |      datetime64[ns]     datetime64[ns]
 |      datetime64[ns, tz] ndarray[object] (Timestamps)
 |      ================== ================================
 |
 |      Examples
 |      --------
 |      >>> ser = pd.Series(pd.Categorical(['a', 'b', 'a']))
 |      >>> ser.to_numpy()
 |      array(['a', 'b', 'a'], dtype=object)
 |
 |      Specify the `dtype` to control how datetime-aware data is represented.
 |      Use ``dtype=object`` to return an ndarray of pandas :class:`Timestamp`
 |      objects, each with the correct ``tz``.
 |
 |      >>> ser = pd.Series(pd.date_range('2000', periods=2, tz="CET"))
 |      >>> ser.to_numpy(dtype=object)
 |      array([Timestamp('2000-01-01 00:00:00+0100', tz='CET'),
 |             Timestamp('2000-01-02 00:00:00+0100', tz='CET')],
 |            dtype=object)
 |
 |      Or ``dtype='datetime64[ns]'`` to return an ndarray of native
 |      datetime64 values. The values are converted to UTC and the timezone
 |      info is dropped.
 |
 |      >>> ser.to_numpy(dtype="datetime64[ns]")
 |      ... # doctest: +ELLIPSIS
 |      array(['1999-12-31T23:00:00.000000000', '2000-01-01T23:00:00...'],
 |            dtype='datetime64[ns]')
 |
 |  tolist(self)
 |      Return a list of the values.
 |
 |      These are each a scalar type, which is a Python scalar
 |      (for str, int, float) or a pandas scalar
 |      (for Timestamp/Timedelta/Interval/Period)
 |
 |      Returns
 |      -------
 |      list
 |
 |      See Also
 |      --------
 |      numpy.ndarray.tolist : Return the array as an a.ndim-levels deep
 |          nested list of Python scalars.
 |
 |  transpose(self: '_T', *args, **kwargs) -> '_T'
 |      Return the transpose, which is by definition self.
 |
 |      Returns
 |      -------
 |      %(klass)s
 |
 |  value_counts(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, dropna: 'bool' = True) -> 'Series'
 |      Return a Series containing counts of unique values.
 |
 |      The resulting object will be in descending order so that the
 |      first element is the most frequently-occurring element.
 |      Excludes NA values by default.
 |
 |      Parameters
 |      ----------
 |      normalize : bool, default False
 |          If True then the object returned will contain the relative
 |          frequencies of the unique values.
 |      sort : bool, default True
 |          Sort by frequencies.
 |      ascending : bool, default False
 |          Sort in ascending order.
 |      bins : int, optional
 |          Rather than count values, group them into half-open bins,
 |          a convenience for ``pd.cut``, only works with numeric data.
 |      dropna : bool, default True
 |          Don't include counts of NaN.
 |
 |      Returns
 |      -------
 |      Series
 |
 |      See Also
 |      --------
 |      Series.count: Number of non-NA elements in a Series.
 |      DataFrame.count: Number of non-NA elements in a DataFrame.
 |      DataFrame.value_counts: Equivalent method on DataFrames.
 |
 |      Examples
 |      --------
 |      >>> index = pd.Index([3, 1, 2, 3, 4, np.nan])
 |      >>> index.value_counts()
 |      3.0    2
 |      1.0    1
 |      2.0    1
 |      4.0    1
 |      dtype: int64
 |
 |      With `normalize` set to `True`, returns the relative frequency by
 |      dividing all values by the sum of values.
 |
 |      >>> s = pd.Series([3, 1, 2, 3, 4, np.nan])
 |      >>> s.value_counts(normalize=True)
 |      3.0    0.4
 |      1.0    0.2
 |      2.0    0.2
 |      4.0    0.2
 |      dtype: float64
 |
 |      **bins**
 |
 |      Bins can be useful for going from a continuous variable to a
 |      categorical variable; instead of counting unique
 |      apparitions of values, divide the index in the specified
 |      number of half-open bins.
 |
 |      >>> s.value_counts(bins=3)
 |      (0.996, 2.0]    2
 |      (2.0, 3.0]      2
 |      (3.0, 4.0]      1
 |      dtype: int64
 |
 |      **dropna**
 |
 |      With `dropna` set to `False` we can also see NaN index values.
 |
 |      >>> s.value_counts(dropna=False)
 |      3.0    2
 |      1.0    1
 |      2.0    1
 |      4.0    1
 |      NaN    1
 |      dtype: int64
 |
 |  ----------------------------------------------------------------------
 |  Readonly properties inherited from pandas.core.base.IndexOpsMixin:
 |
 |  T
 |      Return the transpose, which is by definition self.
 |
 |  empty
 |
 |  nbytes
 |      Return the number of bytes in the underlying data.
 |
 |  ndim
 |      Number of dimensions of the underlying data, by definition 1.
 |
 |  size
 |      Return the number of elements in the underlying data.
 |
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from pandas.core.base.IndexOpsMixin:
 |
 |  __array_priority__ = 1000
 |
 |  ----------------------------------------------------------------------
 |  Methods inherited from pandas.core.arraylike.OpsMixin:
 |
 |  __add__(self, other)
 |
 |  __divmod__(self, other)
 |
 |  __eq__(self, other)
 |      Return self==value.
 |
 |  __floordiv__(self, other)
 |
 |  __ge__(self, other)
 |      Return self>=value.
 |
 |  __gt__(self, other)
 |      Return self>value.
 |
 |  __le__(self, other)
 |      Return self<=value.
 |
 |  __lt__(self, other)
 |      Return self<value.
 |
 |  __mod__(self, other)
 |
 |  __mul__(self, other)
 |
 |  __ne__(self, other)
 |      Return self!=value.
 |
 |  __pow__(self, other)
 |
 |  __radd__(self, other)
 |
 |  __rand__(self, other)
 |
 |  __rdivmod__(self, other)
 |
 |  __rfloordiv__(self, other)
 |
 |  __rmod__(self, other)
 |
 |  __rmul__(self, other)
 |
 |  __ror__(self, other)
 |      Return value|self.
 |
 |  __rpow__(self, other)
 |
 |  __rsub__(self, other)
 |
 |  __rtruediv__(self, other)
 |
 |  __rxor__(self, other)
 |
 |  __sub__(self, other)
 |
 |  __truediv__(self, other)
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pandas.core.arraylike.OpsMixin:
 |
 |  __dict__
 |      dictionary for instance variables (if defined)
 |
 |  __weakref__
 |      list of weak references to the object (if defined)
 |
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from pandas.core.arraylike.OpsMixin:
 |
 |  __hash__ = None
 |
 |  ----------------------------------------------------------------------
 |  Methods inherited from pandas.core.base.PandasObject:
 |
 |  __sizeof__(self) -> 'int'
 |      Generates the total memory usage for an object that returns
 |      either a value or Series of values
 |
 |  ----------------------------------------------------------------------
 |  Methods inherited from pandas.core.accessor.DirNamesMixin:
 |
 |  __dir__(self) -> 'list[str]'
 |      Provide method name lookup and completion.
 |
 |      Notes
 |      -----
 |      Only provide 'public' methods.
