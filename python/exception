#!/usr/bin/env python

import sys
import os
class foo(Exception): pass
class bar(Exception): pass

try:
    raise foo ("help")
except (foo, bar) as e:
    print "Raised", e
    print "dir", dir(e)
    print 'raise.format: {}'.format(e)
    sys.stderr.write("{}: cannot write {}/{}: {}\n".format(
        os.path.basename(sys.argv[0]), "foo", "bar", e))


def f():
    try:
        print 'try'
        raise foo('bar')
        return 5
    except:
        print 'except'
    finally:
        print 'finally'
        # If there is an exception before return in try, then
        # the function returns None unless the finally clause returns a value.
        # If not, it returns 5 and executes the finally clause
        # and still returns 5, regardless of whehter or not the finally
        # clause returns.  Returning something from a finally clause is bad practice

a= f()
print 'f returns:', a

try:
    print 'try/finally with no except ',
finally:
    print 'is ok'


try:
    f = open('/non/extant/file', 'r')
except IOError as e:
    sys.stderr.write("{}: {}: {}\n".format(
        os.path.basename(sys.argv[0]), e.filename, e.strerror))
    raise SystemExit("{}: {}: {}".format(
        os.path.basename(sys.argv[0]), e.filename, e.strerror))
except Exception as e:
    raise SystemExit("{}: {}".format(
        os.path.basename(sys.argv[0]), e))
